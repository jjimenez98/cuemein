{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('./util');\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\n\n\nvar StateMachine = function (_super) {\n  __extends(StateMachine, _super);\n  /**\n   * Construct a {@link StateMachine}.\n   * @param {string} initialState - the intiial state\n   * @param {object} states\n   */\n\n\n  function StateMachine(initialState, states) {\n    var _this = _super.call(this) || this;\n\n    var lock = null;\n    var state = initialState;\n    states = transformStates(states);\n    Object.defineProperties(_this, {\n      _lock: {\n        get: function get() {\n          return lock;\n        },\n        set: function set(_lock) {\n          lock = _lock;\n        }\n      },\n      _reachableStates: {\n        value: reachable(states)\n      },\n      _state: {\n        get: function get() {\n          return state;\n        },\n        set: function set(_state) {\n          state = _state;\n        }\n      },\n      _states: {\n        value: states\n      },\n      _whenDeferreds: {\n        value: new Set()\n      },\n      isLocked: {\n        enumerable: true,\n        get: function get() {\n          return lock !== null;\n        }\n      },\n      state: {\n        enumerable: true,\n        get: function get() {\n          return state;\n        }\n      }\n    });\n\n    _this.on('stateChanged', function (state) {\n      _this._whenDeferreds.forEach(function (deferred) {\n        deferred.when(state, deferred.resolve, deferred.reject);\n      });\n    });\n\n    return _this;\n  }\n  /**\n   * Returns a promise whose executor function is called on each state change.\n   * @param {function(state: string, resolve: function, reject: function): void} when\n   * @returns {Promise.<*>}\n   * @private\n   */\n\n\n  StateMachine.prototype._whenPromise = function (when) {\n    var _this = this;\n\n    if (typeof when !== 'function') {\n      return Promise.reject(new Error('when() executor must be a function'));\n    }\n\n    var deferred = util.defer();\n    deferred.when = when;\n\n    this._whenDeferreds.add(deferred);\n\n    return deferred.promise.then(function (payload) {\n      _this._whenDeferreds.delete(deferred);\n\n      return payload;\n    }, function (error) {\n      _this._whenDeferreds.delete(deferred);\n\n      throw error;\n    });\n  };\n  /**\n   * This method takes a lock and passes the {@link StateMachine#Key} to your\n   * transition function. You may perform zero or more state transitions in your\n   * transition function, but you should check for preemption in each tick. You\n   * may also reenter the lock. Once the Promise returned by your transition\n   * function resolves or rejects, this method releases the lock it acquired for\n   * you.\n   * @param {string} name - a name for the lock\n   * @param {function(StateMachine#Key): Promise} transitionFunction\n   * @returns {Promise}\n   */\n  // NOTE(mroberts): This method is named after a Haskell function:\n  // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n\n\n  StateMachine.prototype.bracket = function (name, transitionFunction) {\n    var key;\n    var self = this;\n\n    function releaseLock(error) {\n      if (self.hasLock(key)) {\n        self.releaseLockCompletely(key);\n      }\n\n      if (error) {\n        throw error;\n      }\n    }\n\n    return this.takeLock(name).then(function gotKey(_key) {\n      key = _key;\n      return transitionFunction(key);\n    }).then(function success(result) {\n      releaseLock();\n      return result;\n    }, releaseLock);\n  };\n  /**\n   * Check whether or not a {@link StateMachine#Key} matches the lock.\n   * @param {StateMachine#Key} key\n   * @returns {boolean}\n   */\n\n\n  StateMachine.prototype.hasLock = function (key) {\n    return this._lock === key;\n  };\n  /**\n   * Preempt any pending state transitions and immediately transition to the new\n   * state. If a lock name is specified, take the lock and return the\n   * {@link StateMachine#Key}.\n   * @param {string} newState\n   * @param {?string} [name=null] - a name for the lock\n   * @param {Array<*>} [payload=[]]\n   * @returns {?StateMachine#Key}\n   */\n\n\n  StateMachine.prototype.preempt = function (newState, name, payload) {\n    // 1. Check that the new state is valid.\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    } // 2. Release the old lock, if any.\n\n\n    var oldLock;\n\n    if (this.isLocked) {\n      oldLock = this._lock;\n      this._lock = null;\n    } // 3. Take the lock, if requested.\n\n\n    var key = null;\n\n    if (name) {\n      key = this.takeLockSync(name);\n    } // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n    // maintain FIFO order of those taking locks.\n\n\n    var preemptionKey = key ? null : this.takeLockSync('preemption'); // 5. Transition.\n\n    this.transition(newState, key || preemptionKey, payload); // 6. Preempt anyone blocked on the old lock.\n\n    if (oldLock) {\n      oldLock.resolve();\n    } // 7. Release the \"preemption\" lock, if we took it.\n\n\n    if (preemptionKey) {\n      this.releaseLock(preemptionKey);\n    }\n\n    return key;\n  };\n  /**\n   * Release a lock. This method succeeds only if the {@link StateMachine} is\n   * still locked and has not been preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n\n\n  StateMachine.prototype.releaseLock = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n\n    if (key.depth === 0) {\n      this._lock = null;\n      key.resolve();\n    } else {\n      key.depth--;\n    }\n  };\n  /**\n   * Release a lock completely, even if it has been reentered. This method\n   * succeeds only if the {@link StateMachine} is still locked and has not been\n   * preempted.\n   * @param {StateMachine#Key} key\n   * @throws Error\n   */\n\n\n  StateMachine.prototype.releaseLockCompletely = function (key) {\n    if (!this.isLocked) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n    } else if (!this.hasLock(key)) {\n      throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n    }\n\n    key.depth = 0;\n    this._lock = null;\n    key.resolve();\n  };\n  /**\n   * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n   * take a lock anytime you intend to perform asynchronous transitions. Calls to\n   * this method are guaranteed to be resolved in FIFO order. You may reenter\n   * a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {Promise<object>}\n   */\n\n\n  StateMachine.prototype.takeLock = function (nameOrKey) {\n    var _this = this; // Reentrant lock\n\n\n    if (typeof nameOrKey === 'object') {\n      var key_1 = nameOrKey;\n      return new Promise(function (resolve) {\n        resolve(_this.takeLockSync(key_1));\n      });\n    } // New lock\n\n\n    var name = nameOrKey;\n\n    if (this.isLocked) {\n      var takeLock = this.takeLock.bind(this, name);\n      return this._lock.promise.then(takeLock);\n    }\n\n    return Promise.resolve(this.takeLockSync(name));\n  };\n  /**\n   * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n   * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n   * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n   * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n   * existing {@link StateMachine#Key}\n   * @returns {object}\n   * @throws Error\n   */\n\n\n  StateMachine.prototype.takeLockSync = function (nameOrKey) {\n    var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n    var name = key ? key.name : nameOrKey;\n\n    if (key && !this.hasLock(key) || !key && this.isLocked) {\n      throw new Error(\"Could not take the lock for \" + name + \" because the lock for \" + this._lock.name + \" was not released\");\n    } // Reentrant lock\n\n\n    if (key) {\n      key.depth++;\n      return key;\n    } // New lock\n\n\n    var lock = makeLock(name);\n    this._lock = lock;\n    return lock;\n  };\n  /**\n   * Transition to a new state. If the {@link StateMachine} is locked, you must\n   * provide the {@link StateMachine#Key}. An invalid state or the wrong\n   * {@link StateMachine#Key} will throw an error.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @throws {Error}\n   */\n\n\n  StateMachine.prototype.transition = function (newState, key, payload) {\n    payload = payload || []; // 1. If we're locked, required the key.\n\n    if (this.isLocked) {\n      if (!key) {\n        throw new Error('You must provide the key in order to ' + 'transition');\n      } else if (!this.hasLock(key)) {\n        throw new Error(\"Could not transition using the key for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n      }\n    } else if (key) {\n      throw new Error(\"Key provided for \" + key.name + \", but the StateMachine was not locked (possibly due to preemption)\");\n    } // 2. Check that the new state is valid.\n\n\n    if (!isValidTransition(this._states, this.state, newState)) {\n      throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n    } // 3. Update the state and emit an event.\n\n\n    this._state = newState;\n    this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));\n  };\n  /**\n   * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n   * this method does not throw.\n   * @param {string} newState\n   * @param {?StateMachine#Key} [key=null]\n   * @param {Array<*>} [payload=[]]\n   * @returns {boolean}\n   */\n\n\n  StateMachine.prototype.tryTransition = function (newState, key, payload) {\n    try {\n      this.transition(newState, key, payload);\n    } catch (error) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Return a Promise that resolves when the {@link StateMachine} transitions to\n   * the specified state. If the {@link StateMachine} transitions such that the\n   * requested state becomes unreachable, the Promise rejects.\n   * @param {string} state\n   * @returns {Promise<this>}\n   */\n\n\n  StateMachine.prototype.when = function (state) {\n    var _this = this;\n\n    if (this.state === state) {\n      return Promise.resolve(this);\n    } else if (!isValidTransition(this._reachableStates, this.state, state)) {\n      return Promise.reject(createUnreachableError(this.state, state));\n    }\n\n    return this._whenPromise(function (newState, resolve, reject) {\n      if (newState === state) {\n        resolve(_this);\n      } else if (!isValidTransition(_this._reachableStates, newState, state)) {\n        reject(createUnreachableError(newState, state));\n      }\n    });\n  };\n\n  return StateMachine;\n}(EventEmitter);\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\n\n\nfunction isValidTransition(graph, from, to) {\n  return graph.get(from).has(to);\n}\n/**\n * @typedef {object} StateMachine#Key\n */\n\n\nfunction makeLock(name) {\n  var lock = util.defer();\n  lock.name = name;\n  lock.depth = 0;\n  return lock;\n}\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\n\n\nfunction reachable(graph) {\n  return Array.from(graph.keys()).reduce(function (newGraph, from) {\n    return newGraph.set(from, reachableFrom(graph, from));\n  }, new Map());\n}\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\n\n\nfunction reachableFrom(graph, from, to) {\n  to = to || new Set();\n  graph.get(from).forEach(function (node) {\n    if (!to.has(node)) {\n      to.add(node);\n      reachableFrom(graph, node, to).forEach(to.add, to);\n    }\n  });\n  return to;\n}\n\nfunction transformStates(states) {\n  var newStates = new Map();\n\n  for (var key in states) {\n    newStates.set(key, new Set(states[key]));\n  }\n\n  return newStates;\n}\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\n\n\nfunction createUnreachableError(here, there) {\n  return new Error(\"\\\"\" + there + \"\\\" cannot be reached from \\\"\" + here + \"\\\"\");\n}\n\nmodule.exports = StateMachine;","map":{"version":3,"sources":["../lib/statemachine.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('./util');\n/**\n * {@link StateMachine} represents a state machine. The state machine supports a\n * reentrant locking mechanism to allow asynchronous state transitions to ensure\n * they have not been preempted. Calls to {@link StateMachine#takeLock} are\n * guaranteed to be resolved in FIFO order.\n * @extends EventEmitter\n * @property {boolean} isLocked - whether or not the {@link StateMachine} is\n *   locked performing asynchronous state transition\n * @property {string} state - the current state\n * @emits {@link StateMachine#stateChanged}\n */\nvar StateMachine = /** @class */ (function (_super) {\n    __extends(StateMachine, _super);\n    /**\n     * Construct a {@link StateMachine}.\n     * @param {string} initialState - the intiial state\n     * @param {object} states\n     */\n    function StateMachine(initialState, states) {\n        var _this = _super.call(this) || this;\n        var lock = null;\n        var state = initialState;\n        states = transformStates(states);\n        Object.defineProperties(_this, {\n            _lock: {\n                get: function () {\n                    return lock;\n                },\n                set: function (_lock) {\n                    lock = _lock;\n                }\n            },\n            _reachableStates: {\n                value: reachable(states)\n            },\n            _state: {\n                get: function () {\n                    return state;\n                },\n                set: function (_state) {\n                    state = _state;\n                }\n            },\n            _states: {\n                value: states\n            },\n            _whenDeferreds: {\n                value: new Set()\n            },\n            isLocked: {\n                enumerable: true,\n                get: function () {\n                    return lock !== null;\n                }\n            },\n            state: {\n                enumerable: true,\n                get: function () {\n                    return state;\n                }\n            }\n        });\n        _this.on('stateChanged', function (state) {\n            _this._whenDeferreds.forEach(function (deferred) {\n                deferred.when(state, deferred.resolve, deferred.reject);\n            });\n        });\n        return _this;\n    }\n    /**\n     * Returns a promise whose executor function is called on each state change.\n     * @param {function(state: string, resolve: function, reject: function): void} when\n     * @returns {Promise.<*>}\n     * @private\n     */\n    StateMachine.prototype._whenPromise = function (when) {\n        var _this = this;\n        if (typeof when !== 'function') {\n            return Promise.reject(new Error('when() executor must be a function'));\n        }\n        var deferred = util.defer();\n        deferred.when = when;\n        this._whenDeferreds.add(deferred);\n        return deferred.promise.then(function (payload) {\n            _this._whenDeferreds.delete(deferred);\n            return payload;\n        }, function (error) {\n            _this._whenDeferreds.delete(deferred);\n            throw error;\n        });\n    };\n    /**\n     * This method takes a lock and passes the {@link StateMachine#Key} to your\n     * transition function. You may perform zero or more state transitions in your\n     * transition function, but you should check for preemption in each tick. You\n     * may also reenter the lock. Once the Promise returned by your transition\n     * function resolves or rejects, this method releases the lock it acquired for\n     * you.\n     * @param {string} name - a name for the lock\n     * @param {function(StateMachine#Key): Promise} transitionFunction\n     * @returns {Promise}\n     */\n    // NOTE(mroberts): This method is named after a Haskell function:\n    // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket\n    StateMachine.prototype.bracket = function (name, transitionFunction) {\n        var key;\n        var self = this;\n        function releaseLock(error) {\n            if (self.hasLock(key)) {\n                self.releaseLockCompletely(key);\n            }\n            if (error) {\n                throw error;\n            }\n        }\n        return this.takeLock(name).then(function gotKey(_key) {\n            key = _key;\n            return transitionFunction(key);\n        }).then(function success(result) {\n            releaseLock();\n            return result;\n        }, releaseLock);\n    };\n    /**\n     * Check whether or not a {@link StateMachine#Key} matches the lock.\n     * @param {StateMachine#Key} key\n     * @returns {boolean}\n     */\n    StateMachine.prototype.hasLock = function (key) {\n        return this._lock === key;\n    };\n    /**\n     * Preempt any pending state transitions and immediately transition to the new\n     * state. If a lock name is specified, take the lock and return the\n     * {@link StateMachine#Key}.\n     * @param {string} newState\n     * @param {?string} [name=null] - a name for the lock\n     * @param {Array<*>} [payload=[]]\n     * @returns {?StateMachine#Key}\n     */\n    StateMachine.prototype.preempt = function (newState, name, payload) {\n        // 1. Check that the new state is valid.\n        if (!isValidTransition(this._states, this.state, newState)) {\n            throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n        }\n        // 2. Release the old lock, if any.\n        var oldLock;\n        if (this.isLocked) {\n            oldLock = this._lock;\n            this._lock = null;\n        }\n        // 3. Take the lock, if requested.\n        var key = null;\n        if (name) {\n            key = this.takeLockSync(name);\n        }\n        // 4. If a lock wasn't requested, take a \"preemption\" lock in order to\n        // maintain FIFO order of those taking locks.\n        var preemptionKey = key ? null : this.takeLockSync('preemption');\n        // 5. Transition.\n        this.transition(newState, key || preemptionKey, payload);\n        // 6. Preempt anyone blocked on the old lock.\n        if (oldLock) {\n            oldLock.resolve();\n        }\n        // 7. Release the \"preemption\" lock, if we took it.\n        if (preemptionKey) {\n            this.releaseLock(preemptionKey);\n        }\n        return key;\n    };\n    /**\n     * Release a lock. This method succeeds only if the {@link StateMachine} is\n     * still locked and has not been preempted.\n     * @param {StateMachine#Key} key\n     * @throws Error\n     */\n    StateMachine.prototype.releaseLock = function (key) {\n        if (!this.isLocked) {\n            throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n        }\n        else if (!this.hasLock(key)) {\n            throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n        }\n        if (key.depth === 0) {\n            this._lock = null;\n            key.resolve();\n        }\n        else {\n            key.depth--;\n        }\n    };\n    /**\n     * Release a lock completely, even if it has been reentered. This method\n     * succeeds only if the {@link StateMachine} is still locked and has not been\n     * preempted.\n     * @param {StateMachine#Key} key\n     * @throws Error\n     */\n    StateMachine.prototype.releaseLockCompletely = function (key) {\n        if (!this.isLocked) {\n            throw new Error(\"Could not release the lock for \" + key.name + \" because the StateMachine is not locked\");\n        }\n        else if (!this.hasLock(key)) {\n            throw new Error(\"Could not release the lock for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n        }\n        key.depth = 0;\n        this._lock = null;\n        key.resolve();\n    };\n    /**\n     * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should\n     * take a lock anytime you intend to perform asynchronous transitions. Calls to\n     * this method are guaranteed to be resolved in FIFO order. You may reenter\n     * a lock by passing its {@link StateMachine#Key}.\n     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n     * existing {@link StateMachine#Key}\n     * @returns {Promise<object>}\n     */\n    StateMachine.prototype.takeLock = function (nameOrKey) {\n        var _this = this;\n        // Reentrant lock\n        if (typeof nameOrKey === 'object') {\n            var key_1 = nameOrKey;\n            return new Promise(function (resolve) {\n                resolve(_this.takeLockSync(key_1));\n            });\n        }\n        // New lock\n        var name = nameOrKey;\n        if (this.isLocked) {\n            var takeLock = this.takeLock.bind(this, name);\n            return this._lock.promise.then(takeLock);\n        }\n        return Promise.resolve(this.takeLockSync(name));\n    };\n    /**\n     * Take a lock, returning the {@Link StateMachine#Key}. This method throws if\n     * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is\n     * provided. You may reenter a lock by passing its {@link StateMachine#Key}.\n     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an\n     * existing {@link StateMachine#Key}\n     * @returns {object}\n     * @throws Error\n     */\n    StateMachine.prototype.takeLockSync = function (nameOrKey) {\n        var key = typeof nameOrKey === 'string' ? null : nameOrKey;\n        var name = key ? key.name : nameOrKey;\n        if (key && !this.hasLock(key) || !key && this.isLocked) {\n            throw new Error(\"Could not take the lock for \" + name + \" because the lock for \" + this._lock.name + \" was not released\");\n        }\n        // Reentrant lock\n        if (key) {\n            key.depth++;\n            return key;\n        }\n        // New lock\n        var lock = makeLock(name);\n        this._lock = lock;\n        return lock;\n    };\n    /**\n     * Transition to a new state. If the {@link StateMachine} is locked, you must\n     * provide the {@link StateMachine#Key}. An invalid state or the wrong\n     * {@link StateMachine#Key} will throw an error.\n     * @param {string} newState\n     * @param {?StateMachine#Key} [key=null]\n     * @param {Array<*>} [payload=[]]\n     * @throws {Error}\n     */\n    StateMachine.prototype.transition = function (newState, key, payload) {\n        payload = payload || [];\n        // 1. If we're locked, required the key.\n        if (this.isLocked) {\n            if (!key) {\n                throw new Error('You must provide the key in order to ' +\n                    'transition');\n            }\n            else if (!this.hasLock(key)) {\n                throw new Error(\"Could not transition using the key for \" + key.name + \" because \" + this._lock.name + \" has the lock\");\n            }\n        }\n        else if (key) {\n            throw new Error(\"Key provided for \" + key.name + \", but the StateMachine was not locked (possibly due to preemption)\");\n        }\n        // 2. Check that the new state is valid.\n        if (!isValidTransition(this._states, this.state, newState)) {\n            throw new Error(\"Cannot transition from \\\"\" + this.state + \"\\\" to \\\"\" + newState + \"\\\"\");\n        }\n        // 3. Update the state and emit an event.\n        this._state = newState;\n        this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));\n    };\n    /**\n     * Attempt to transition to a new state. Unlike {@link StateMachine#transition},\n     * this method does not throw.\n     * @param {string} newState\n     * @param {?StateMachine#Key} [key=null]\n     * @param {Array<*>} [payload=[]]\n     * @returns {boolean}\n     */\n    StateMachine.prototype.tryTransition = function (newState, key, payload) {\n        try {\n            this.transition(newState, key, payload);\n        }\n        catch (error) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Return a Promise that resolves when the {@link StateMachine} transitions to\n     * the specified state. If the {@link StateMachine} transitions such that the\n     * requested state becomes unreachable, the Promise rejects.\n     * @param {string} state\n     * @returns {Promise<this>}\n     */\n    StateMachine.prototype.when = function (state) {\n        var _this = this;\n        if (this.state === state) {\n            return Promise.resolve(this);\n        }\n        else if (!isValidTransition(this._reachableStates, this.state, state)) {\n            return Promise.reject(createUnreachableError(this.state, state));\n        }\n        return this._whenPromise(function (newState, resolve, reject) {\n            if (newState === state) {\n                resolve(_this);\n            }\n            else if (!isValidTransition(_this._reachableStates, newState, state)) {\n                reject(createUnreachableError(newState, state));\n            }\n        });\n    };\n    return StateMachine;\n}(EventEmitter));\n/**\n * @event StateMachine#stateChanged\n * @param {string} newState\n */\n/**\n * Check if a transition is valid.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {*} to\n * @returns {boolean}\n */\nfunction isValidTransition(graph, from, to) {\n    return graph.get(from).has(to);\n}\n/**\n * @typedef {object} StateMachine#Key\n */\nfunction makeLock(name) {\n    var lock = util.defer();\n    lock.name = name;\n    lock.depth = 0;\n    return lock;\n}\n/**\n * Compute the transitive closure of a graph (i.e. what nodes are reachable from\n * where).\n * @private\n * @param {Map<*, Set<*>>} graph\n * @returns {Map<*, Set<*>>}\n */\nfunction reachable(graph) {\n    return Array.from(graph.keys()).reduce(function (newGraph, from) { return newGraph.set(from, reachableFrom(graph, from)); }, new Map());\n}\n/**\n * Compute the Set of node reachable from a particular node in the graph.\n * @private\n * @param {Map<*, Set<*>>} graph\n * @param {*} from\n * @param {Set<*>} [to]\n * @returns {Set<*>}\n */\nfunction reachableFrom(graph, from, to) {\n    to = to || new Set();\n    graph.get(from).forEach(function (node) {\n        if (!to.has(node)) {\n            to.add(node);\n            reachableFrom(graph, node, to).forEach(to.add, to);\n        }\n    });\n    return to;\n}\nfunction transformStates(states) {\n    var newStates = new Map();\n    for (var key in states) {\n        newStates.set(key, new Set(states[key]));\n    }\n    return newStates;\n}\n/**\n * Create an \"unreachable state\" Error.\n * @param {string} here\n * @param {string} there\n * @returns {Error}\n */\nfunction createUnreachableError(here, there) {\n    return new Error(\"\\\"\" + there + \"\\\" cannot be reached from \\\"\" + here + \"\\\"\");\n}\nmodule.exports = StateMachine;\n//# sourceMappingURL=statemachine.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar util = require('../../');\n\nvar getMediaSections = require('../').getMediaSections; // NOTE(mroberts): OrderedTrackMatcher is meant to solve the problem identified in\n//\n//   https://bugs.webkit.org/show_bug.cgi?id=174519\n//\n// Namely that, without MIDs, we cannot \"correctly\" identify MediaStreamTracks\n// in Safari's current WebRTC implementation. So, this module tries to hack\n// around this by making a possibly dangerous assumption: \"track\" events will\n// be raised for MediaStreamTracks of a particular kind in the same order that\n// those kinds' MSIDs appear in the SDP. By calling `update` with an\n// RTCPeerConnection's `remoteDescription` and then invoking `match`, we ought\n// to be able to dequeue MediaStreamTrack IDs in the correct order to be\n// assigned to \"track\" events.\n\n/**\n * @interface MatchedAndUnmatched\n * @property {Set<Track.ID>} matched\n * @property {Set<Track.ID>} unmatched\n */\n\n/**\n * Create a new instance of {@link MatchedAndUnmatched}.\n * @returns {MatchedAndUnmatched}\n */\n\n\nfunction create() {\n  return {\n    matched: new Set(),\n    unmatched: new Set()\n  };\n}\n/**\n * Attempt to match a MediaStreamTrack ID.\n * @param {MatchedAndUnmatched} mAndM\n * @returns {?Track.ID} id\n */\n\n\nfunction match(mAndM) {\n  var unmatched = Array.from(mAndM.unmatched);\n\n  if (!unmatched.length) {\n    return null;\n  }\n\n  var id = unmatched[0];\n  mAndM.matched.add(id);\n  mAndM.unmatched.delete(id);\n  return id;\n}\n/**\n * Update a {@link MatchedAndUnmatched}'s MediaStreamTrack IDs.\n * @param {MatchedAndUnmatched} mAndM\n * @param {Set<Track.ID>} ids\n * @returns {void}\n */\n\n\nfunction update(mAndM, ids) {\n  ids = new Set(ids);\n  var removedMatchedIds = util.difference(mAndM.matched, ids);\n  removedMatchedIds.forEach(mAndM.matched.delete, mAndM.matched);\n  mAndM.unmatched = util.difference(ids, mAndM.matched);\n}\n/**\n * Parse MediaStreamTrack IDs of a particular kind from an SDP.\n * @param {string} kind\n * @param {string} sdp\n * @returns {Set<Track.ID>} ids\n */\n\n\nfunction parse(kind, sdp) {\n  var mediaSections = getMediaSections(sdp, kind);\n  var pattern = 'msid: ?(.+) +(.+) ?$';\n  return new Set(util.flatMap(mediaSections, function (mediaSection) {\n    return mediaSection.match(new RegExp(pattern, 'mg')) || [];\n  }).map(function (msid) {\n    return msid.match(new RegExp(pattern))[2];\n  }));\n}\n/**\n * A {@link OrderedTrackMatcher} is used to match RTCTrackEvents.\n * @property {MatchedAndUnmatched} audio\n * @property {MatchedAndUnmatched} video\n */\n\n\nvar OrderedTrackMatcher = function () {\n  function OrderedTrackMatcher() {\n    if (!(this instanceof OrderedTrackMatcher)) {\n      return new OrderedTrackMatcher();\n    }\n\n    Object.defineProperties(this, {\n      audio: {\n        enumerable: true,\n        value: create()\n      },\n      video: {\n        enumerable: true,\n        value: create()\n      }\n    });\n  }\n  /**\n   * Attempt to match a new MediaStreamTrack ID.\n   * @param {RTCTrackEvent} event\n   * @returns {?Track.ID} id\n   */\n\n\n  OrderedTrackMatcher.prototype.match = function (event) {\n    return match(this[event.track.kind]);\n  };\n  /**\n   * Update the {@link OrderedTrackMatcher} with a new SDP.\n   * @param {string} sdp\n   * @returns {void}\n   */\n\n\n  OrderedTrackMatcher.prototype.update = function (sdp) {\n    ['audio', 'video'].forEach(function (kind) {\n      update(this[kind], parse(kind, sdp));\n    }, this);\n  };\n\n  return OrderedTrackMatcher;\n}();\n\nmodule.exports = OrderedTrackMatcher;","map":{"version":3,"sources":["../../../../lib/util/sdp/trackmatcher/ordered.js"],"names":[],"mappings":"AAAA;;AAEA,IAAM,IAAI,GAAG,OAAO,CAAC,QAAD,CAApB;;AACA,IAAM,gBAAgB,GAAG,OAAO,CAAC,KAAD,CAAP,CAAe,gBAAxC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIG;;AAEH;;;AAGG;;;AACH,SAAS,MAAT,GAAe;AACb,SAAO;AACL,IAAA,OAAO,EAAE,IAAI,GAAJ,EADJ;AAEL,IAAA,SAAS,EAAE,IAAI,GAAJ;AAFN,GAAP;AAID;AAED;;;;AAIG;;;AACH,SAAS,KAAT,CAAe,KAAf,EAAoB;AAClB,MAAM,SAAS,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,SAAjB,CAAlB;;AACA,MAAI,CAAC,SAAS,CAAC,MAAf,EAAuB;AACrB,WAAO,IAAP;AACD;;AACD,MAAM,EAAE,GAAG,SAAS,CAAC,CAAD,CAApB;AACA,EAAA,KAAK,CAAC,OAAN,CAAc,GAAd,CAAkB,EAAlB;AACA,EAAA,KAAK,CAAC,SAAN,CAAgB,MAAhB,CAAuB,EAAvB;AACA,SAAO,EAAP;AACD;AAED;;;;;AAKG;;;AACH,SAAS,MAAT,CAAgB,KAAhB,EAAuB,GAAvB,EAA0B;AACxB,EAAA,GAAG,GAAG,IAAI,GAAJ,CAAQ,GAAR,CAAN;AACA,MAAM,iBAAiB,GAAG,IAAI,CAAC,UAAL,CAAgB,KAAK,CAAC,OAAtB,EAA+B,GAA/B,CAA1B;AACA,EAAA,iBAAiB,CAAC,OAAlB,CAA0B,KAAK,CAAC,OAAN,CAAc,MAAxC,EAAgD,KAAK,CAAC,OAAtD;AACA,EAAA,KAAK,CAAC,SAAN,GAAkB,IAAI,CAAC,UAAL,CAAgB,GAAhB,EAAqB,KAAK,CAAC,OAA3B,CAAlB;AACD;AAED;;;;;AAKG;;;AACH,SAAS,KAAT,CAAe,IAAf,EAAqB,GAArB,EAAwB;AACtB,MAAM,aAAa,GAAG,gBAAgB,CAAC,GAAD,EAAM,IAAN,CAAtC;AACA,MAAM,OAAO,GAAG,sBAAhB;AACA,SAAO,IAAI,GAAJ,CAAQ,IAAI,CAAC,OAAL,CAAa,aAAb,EAA4B,UAAA,YAAA,EAAY;AAAI,WAAA,YAAY,CAAC,KAAb,CAAmB,IAAI,MAAJ,CAAW,OAAX,EAAoB,IAApB,CAAnB,KAAA,EAAA;AAAmD,GAA/F,EAAiG,GAAjG,CAAqG,UAAA,IAAA,EAAI;AAAI,WAAA,IAAI,CAAC,KAAL,CAAW,IAAI,MAAJ,CAAW,OAAX,CAAX,EAAA,CAAA,CAAA;AAAkC,GAA/I,CAAR,CAAP;AACD;AAED;;;;AAIG;;;AACH,IAAA,mBAAA,GAAA,YAAA;AACE,WAAA,mBAAA,GAAA;AACE,QAAI,EAAE,gBAAgB,mBAAlB,CAAJ,EAA4C;AAC1C,aAAO,IAAI,mBAAJ,EAAP;AACD;;AACD,IAAA,MAAM,CAAC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5B,MAAA,KAAK,EAAE;AACL,QAAA,UAAU,EAAE,IADP;AAEL,QAAA,KAAK,EAAE,MAAM;AAFR,OADqB;AAK5B,MAAA,KAAK,EAAE;AACL,QAAA,UAAU,EAAE,IADP;AAEL,QAAA,KAAK,EAAE,MAAM;AAFR;AALqB,KAA9B;AAUD;AAED;;;;AAIG;;;AACH,EAAA,mBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,KAAN,EAAW;AACT,WAAO,KAAK,CAAC,KAAK,KAAK,CAAC,KAAN,CAAY,IAAjB,CAAD,CAAZ;AACD,GAFD;AAIA;;;;AAIG;;;AACH,EAAA,mBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,GAAP,EAAU;AACR,KAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,CAA2B,UAAS,IAAT,EAAa;AACtC,MAAA,MAAM,CAAC,KAAK,IAAL,CAAD,EAAa,KAAK,CAAC,IAAD,EAAO,GAAP,CAAlB,CAAN;AACD,KAFD,EAEG,IAFH;AAGD,GAJD;;AAKF,SAAA,mBAAA;AAAC,CApCD,EAAA;;AAsCA,MAAM,CAAC,OAAP,GAAiB,mBAAjB","sourceRoot":"","sourcesContent":["'use strict';\nvar util = require('../../');\nvar getMediaSections = require('../').getMediaSections;\n// NOTE(mroberts): OrderedTrackMatcher is meant to solve the problem identified in\n//\n//   https://bugs.webkit.org/show_bug.cgi?id=174519\n//\n// Namely that, without MIDs, we cannot \"correctly\" identify MediaStreamTracks\n// in Safari's current WebRTC implementation. So, this module tries to hack\n// around this by making a possibly dangerous assumption: \"track\" events will\n// be raised for MediaStreamTracks of a particular kind in the same order that\n// those kinds' MSIDs appear in the SDP. By calling `update` with an\n// RTCPeerConnection's `remoteDescription` and then invoking `match`, we ought\n// to be able to dequeue MediaStreamTrack IDs in the correct order to be\n// assigned to \"track\" events.\n/**\n * @interface MatchedAndUnmatched\n * @property {Set<Track.ID>} matched\n * @property {Set<Track.ID>} unmatched\n */\n/**\n * Create a new instance of {@link MatchedAndUnmatched}.\n * @returns {MatchedAndUnmatched}\n */\nfunction create() {\n    return {\n        matched: new Set(),\n        unmatched: new Set()\n    };\n}\n/**\n * Attempt to match a MediaStreamTrack ID.\n * @param {MatchedAndUnmatched} mAndM\n * @returns {?Track.ID} id\n */\nfunction match(mAndM) {\n    var unmatched = Array.from(mAndM.unmatched);\n    if (!unmatched.length) {\n        return null;\n    }\n    var id = unmatched[0];\n    mAndM.matched.add(id);\n    mAndM.unmatched.delete(id);\n    return id;\n}\n/**\n * Update a {@link MatchedAndUnmatched}'s MediaStreamTrack IDs.\n * @param {MatchedAndUnmatched} mAndM\n * @param {Set<Track.ID>} ids\n * @returns {void}\n */\nfunction update(mAndM, ids) {\n    ids = new Set(ids);\n    var removedMatchedIds = util.difference(mAndM.matched, ids);\n    removedMatchedIds.forEach(mAndM.matched.delete, mAndM.matched);\n    mAndM.unmatched = util.difference(ids, mAndM.matched);\n}\n/**\n * Parse MediaStreamTrack IDs of a particular kind from an SDP.\n * @param {string} kind\n * @param {string} sdp\n * @returns {Set<Track.ID>} ids\n */\nfunction parse(kind, sdp) {\n    var mediaSections = getMediaSections(sdp, kind);\n    var pattern = 'msid: ?(.+) +(.+) ?$';\n    return new Set(util.flatMap(mediaSections, function (mediaSection) { return mediaSection.match(new RegExp(pattern, 'mg')) || []; }).map(function (msid) { return msid.match(new RegExp(pattern))[2]; }));\n}\n/**\n * A {@link OrderedTrackMatcher} is used to match RTCTrackEvents.\n * @property {MatchedAndUnmatched} audio\n * @property {MatchedAndUnmatched} video\n */\nvar OrderedTrackMatcher = /** @class */ (function () {\n    function OrderedTrackMatcher() {\n        if (!(this instanceof OrderedTrackMatcher)) {\n            return new OrderedTrackMatcher();\n        }\n        Object.defineProperties(this, {\n            audio: {\n                enumerable: true,\n                value: create()\n            },\n            video: {\n                enumerable: true,\n                value: create()\n            }\n        });\n    }\n    /**\n     * Attempt to match a new MediaStreamTrack ID.\n     * @param {RTCTrackEvent} event\n     * @returns {?Track.ID} id\n     */\n    OrderedTrackMatcher.prototype.match = function (event) {\n        return match(this[event.track.kind]);\n    };\n    /**\n     * Update the {@link OrderedTrackMatcher} with a new SDP.\n     * @param {string} sdp\n     * @returns {void}\n     */\n    OrderedTrackMatcher.prototype.update = function (sdp) {\n        ['audio', 'video'].forEach(function (kind) {\n            update(this[kind], parse(kind, sdp));\n        }, this);\n    };\n    return OrderedTrackMatcher;\n}());\nmodule.exports = OrderedTrackMatcher;\n//# sourceMappingURL=ordered.js.map"]},"metadata":{},"sourceType":"script"}
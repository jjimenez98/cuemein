{"ast":null,"code":"'use strict';\n\nvar detectSilence = require('./detectsilence');\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\n\n\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0; // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n\n  var AudioContextFactory = require('./audiocontext');\n\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<MediaStream>}\n   */\n\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n\n        log.warn(\"Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #\" + ++retry + \".\");\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;","map":{"version":3,"sources":["../../lib/webaudio/workaround180748.js"],"names":[],"mappings":"AAAA;;AAEA,IAAM,aAAa,GAAG,OAAO,CAAC,iBAAD,CAA7B;AAEA;;;;;;;;;;;;;;;;;;;AAmBG;;;AACH,SAAS,UAAT,CAAoB,GAApB,EAAyB,YAAzB,EAAuC,WAAvC,EAAoD,CAApD,EAAuD,OAAvD,EAA8D;AAC5D,EAAA,CAAC,GAAG,OAAO,CAAP,KAAa,QAAb,GAAwB,CAAxB,GAA4B,CAAhC;AACA,MAAI,KAAK,GAAG,CAAZ,CAF4D,CAI5D;AACA;;AACA,MAAM,mBAAmB,GAAG,OAAO,CAAC,gBAAD,CAAnC;;AACA,MAAM,MAAM,GAAG,EAAf;AACA,MAAM,YAAY,GAAG,mBAAmB,CAAC,WAApB,CAAgC,MAAhC,CAArB;AAEA;;;AAGG;;AACH,WAAS,YAAT,GAAqB;AACnB,WAAO,YAAY,CAAC,WAAD,CAAZ,CAA0B,IAA1B,CAA+B,UAAA,MAAA,EAAM;AAC1C,UAAM,eAAe,GAAG,WAAW,CAAC,KAAZ,GACpB,aAAa,CAAC,YAAD,EAAe,MAAf,EAAuB,OAAvB,CAAb,CAA6C,KAA7C,CAAmD,UAAA,GAAA,EAAG;AACtD,QAAA,GAAG,CAAC,IAAJ,CAAS,8CAAT,EAAyD,GAAzD;AACA,eAAO,IAAP;AACD,OAHC,CADoB,GAKpB,OAAO,CAAC,OAAR,CAAgB,KAAhB,CALJ;AAMA,aAAO,eAAe,CAAC,IAAhB,CAAqB,UAAA,QAAA,EAAQ;AAClC,YAAI,CAAC,QAAL,EAAe;AACb,UAAA,GAAG,CAAC,IAAJ,CAAS,wDAAT;AACA,iBAAO,MAAP;AACD,SAHD,MAGO,IAAI,CAAC,IAAI,CAAT,EAAY;AACjB,UAAA,GAAG,CAAC,IAAJ,CAAS;AACmD,sEAD5D;AAEA,iBAAO,MAAP;AACD;;AACD,QAAA,GAAG,CAAC,IAAJ,CAAS,wHAEd,EAAE,KAFY,GAEP,GAFF;AAGA,QAAA,MAAM,CAAC,SAAP,GAAmB,OAAnB,CAA2B,UAAA,KAAA,EAAK;AAAI,iBAAA,KAAK,CAAL,IAAA,EAAA;AAAY,SAAhD;AACA,QAAA,CAAC;AACD,eAAO,YAAY,EAAnB;AACD,OAfM,CAAP;AAgBD,KAvBM,CAAP;AAwBD;;AAED,SAAO,YAAY,GAAG,IAAf,CAAoB,UAAA,MAAA,EAAM;AAC/B,IAAA,mBAAmB,CAAC,OAApB,CAA4B,MAA5B;AACA,WAAO,MAAP;AACD,GAHM,EAGJ,UAAA,KAAA,EAAK;AACN,IAAA,mBAAmB,CAAC,OAApB,CAA4B,MAA5B;AACA,UAAM,KAAN;AACD,GANM,CAAP;AAOD;;AAED,MAAM,CAAC,OAAP,GAAiB,UAAjB","sourceRoot":"","sourcesContent":["'use strict';\nvar detectSilence = require('./detectsilence');\n/**\n * This function attempts to workaround WebKit Bug 180748. It does so by\n *\n *   1. Calling `getUserMedia`, and\n *   2. Checking to see if the resulting MediaStream is silent.\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\n *\n * The function only repeats up to `n` times, and it only waits `timeout`\n * milliseconds when detecting silence. Assuming `getUserMedia` is\n * instantaneous, in the best case, this function returns a Promise that\n * resolves immediately; in the worst case, this function returns a Promise that\n * resolves in `n` * `timeout` milliseconds.\n *\n * @param {Log} log\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\n * @param {MediaStreamConstraints} constraints\n * @param {number} [n=3]\n * @param {number} [timeout=250]\n * @returns Promise<MediaStream>\n */\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n    n = typeof n === 'number' ? n : 3;\n    var retry = 0;\n    // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n    // it exports a default instance whose constructor calls Object.assign.\n    var AudioContextFactory = require('./audiocontext');\n    var holder = {};\n    var audioContext = AudioContextFactory.getOrCreate(holder);\n    /**\n     * We can't use async/await yet, so I need to factor this out.\n     * @returns {Promise<MediaStream>}\n     */\n    function doWorkaround() {\n        return getUserMedia(constraints).then(function (stream) {\n            var isSilentPromise = constraints.audio\n                ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n                    log.warn('Encountered an error while detecting silence', err);\n                    return true;\n                })\n                : Promise.resolve(false);\n            return isSilentPromise.then(function (isSilent) {\n                if (!isSilent) {\n                    log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n                    return stream;\n                }\n                else if (n <= 0) {\n                    log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n                    return stream;\n                }\n                log.warn(\"Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #\" + ++retry + \".\");\n                stream.getTracks().forEach(function (track) { return track.stop(); });\n                n--;\n                return doWorkaround();\n            });\n        });\n    }\n    return doWorkaround().then(function (stream) {\n        AudioContextFactory.release(holder);\n        return stream;\n    }, function (error) {\n        AudioContextFactory.release(holder);\n        throw error;\n    });\n}\nmodule.exports = workaround;\n//# sourceMappingURL=workaround180748.js.map"]},"metadata":{},"sourceType":"script"}
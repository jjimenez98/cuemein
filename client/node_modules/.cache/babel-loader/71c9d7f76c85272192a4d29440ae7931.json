{"ast":null,"code":"'use strict';\n\nvar RTCSessionDescription = require('@twilio/webrtc').RTCSessionDescription;\n\nvar createPtToCodecName = require('./').createPtToCodecName;\n\nvar getMediaSections = require('./').getMediaSections;\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\n\n\nfunction workaround(description) {\n  var descriptionInit = {\n    type: description.type\n  };\n\n  if (description.type !== 'rollback') {\n    descriptionInit.sdp = sdpWorkaround(description.sdp);\n  }\n\n  return new RTCSessionDescription(descriptionInit);\n}\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\n\n\nfunction sdpWorkaround(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(mediaSectionWorkaround)).join('\\r\\n');\n}\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\n\n\nfunction mediaSectionWorkaround(mediaSection) {\n  var ptToCodecName = createPtToCodecName(mediaSection);\n  mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n  var codecNameToPts = createCodecNameToPts(ptToCodecName);\n  var rtxPts = codecNameToPts.get('rtx') || new Set();\n  var invalidRtxPts = new Set();\n  var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n  var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);\n  var unassociatedRtxPts = Array.from(invalidRtxPts); // NOTE(mroberts): We normalize to lowercase.\n\n  var knownCodecNames = ['h264', 'vp8', 'vp9'];\n  var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return Array.from(pts).reduce(function (unassociatedPts, pt) {\n      return associatedPtToRtxPt.has(pt) ? unassociatedPts : unassociatedPts.add(pt);\n    }, unassociatedPts);\n  }, new Set());\n  unassociatedPts.forEach(function (pt) {\n    if (unassociatedRtxPts.length) {\n      var rtxPt = unassociatedRtxPts.shift();\n      mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n      mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n    }\n  });\n  unassociatedRtxPts.forEach(function (rtxPt) {\n    mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n    mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n  });\n  return mediaSection;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n  // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n  // with duplicate \"rtx\" payload mapping in media section. When applied,\n  // Chrome rejects the SDP. We workaround this by deleting duplicate\n  // \"rtx\" mappings found in SDP.\n  return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {\n    var rtpmapRegex = new RegExp(\"^a=rtpmap:\" + pt + \" rtx.+$\", 'gm');\n    return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {\n      var rtpmapRegex = new RegExp(\"\\r\\n\" + rtpmap);\n      var fmtpmapRegex = new RegExp(\"\\r\\na=fmtp:\" + pt + \" apt=[0-9]+\");\n      return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n    }, section);\n  }, mediaSection);\n}\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\n\n\nfunction createCodecNameToPts(ptToCodecName) {\n  var codecNameToPts = new Map();\n  ptToCodecName.forEach(function (codecName, pt) {\n    var pts = codecNameToPts.get(codecName) || new Set();\n    return codecNameToPts.set(codecName, pts.add(pt));\n  });\n  return codecNameToPts;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\n\n\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n  return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {\n    var fmtpPattern = new RegExp(\"a=fmtp:\" + rtxPt + \" apt=(\\\\d+)\");\n    var matches = mediaSection.match(fmtpPattern);\n\n    if (!matches) {\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var pt = Number.parseInt(matches[1]);\n\n    if (!ptToCodecName.has(pt)) {\n      // This is Issue 8329.\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    var codecName = ptToCodecName.get(pt);\n\n    if (codecName === 'rtx') {\n      // Strange\n      invalidRtxPts.add(rtxPt);\n      return rtxPtToAssociatedPt;\n    }\n\n    return rtxPtToAssociatedPt.set(rtxPt, pt);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\n\n\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n  // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n  var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {\n    var rtxPt = pair[0];\n    var pt = pair[1];\n    var rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n    return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n  }, new Map()); // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n  // same NonRtxPT are removed and added to invalidRtxPts.\n\n  return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {\n    var pt = pair[0];\n    var rtxPts = Array.from(pair[1]);\n\n    if (rtxPts.length > 1) {\n      rtxPts.forEach(function (rtxPt) {\n        invalidRtxPts.add(rtxPt);\n      });\n      return associatedPtToRtxPt;\n    }\n\n    return associatedPtToRtxPt.set(pt, rtxPts[0]);\n  }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp(\"a=fmtp:\" + rtxPt + \".*\\r\\n\", 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\n\n\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n  var pattern = new RegExp(\"a=rtpmap:\" + rtxPt + \".*\\r\\n\", 'gm');\n  return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\n\n\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n  return mediaSection.endsWith('\\r\\n') ? mediaSection + \"a=fmtp:\" + rtxPt + \" apt=\" + pt + \"\\r\\n\" : mediaSection + \"\\r\\na=fmtp:\" + rtxPt + \" apt=\" + pt;\n}\n\nmodule.exports = workaround;","map":{"version":3,"sources":["../../../lib/util/sdp/issue8329.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar RTCSessionDescription = require('@twilio/webrtc').RTCSessionDescription;\nvar createPtToCodecName = require('./').createPtToCodecName;\nvar getMediaSections = require('./').getMediaSections;\n/**\n * An RTX payload type\n * @typedef {PT} RtxPT\n */\n/**\n * A non-RTX payload type\n * @typedef {PT} NonRtxPT\n */\n/**\n * A Set with at least one element\n * @typedef {Set} NonEmptySet\n */\n/**\n * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.\n * @param {RTCSessionDescriptionInit} description\n * @returns {RTCSessionDescription} newDescription\n */\nfunction workaround(description) {\n    var descriptionInit = { type: description.type };\n    if (description.type !== 'rollback') {\n        descriptionInit.sdp = sdpWorkaround(description.sdp);\n    }\n    return new RTCSessionDescription(descriptionInit);\n}\n/**\n * @param {string} sdp\n * @returns {string} newSdp\n */\nfunction sdpWorkaround(sdp) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    return [session]\n        .concat(mediaSections.map(mediaSectionWorkaround))\n        .join('\\r\\n');\n}\n/**\n * @param {string} mediaSection\n * @returns {string} newMediaSection\n */\nfunction mediaSectionWorkaround(mediaSection) {\n    var ptToCodecName = createPtToCodecName(mediaSection);\n    mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);\n    var codecNameToPts = createCodecNameToPts(ptToCodecName);\n    var rtxPts = codecNameToPts.get('rtx') || new Set();\n    var invalidRtxPts = new Set();\n    var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);\n    var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);\n    var unassociatedRtxPts = Array.from(invalidRtxPts);\n    // NOTE(mroberts): We normalize to lowercase.\n    var knownCodecNames = ['h264', 'vp8', 'vp9'];\n    var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {\n        var pts = codecNameToPts.get(codecName) || new Set();\n        return Array.from(pts).reduce(function (unassociatedPts, pt) { return associatedPtToRtxPt.has(pt)\n            ? unassociatedPts\n            : unassociatedPts.add(pt); }, unassociatedPts);\n    }, new Set());\n    unassociatedPts.forEach(function (pt) {\n        if (unassociatedRtxPts.length) {\n            var rtxPt = unassociatedRtxPts.shift();\n            mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n            mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);\n        }\n    });\n    unassociatedRtxPts.forEach(function (rtxPt) {\n        mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);\n        mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);\n    });\n    return mediaSection;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {string} newMediaSection\n */\nfunction deleteDuplicateRtxPts(mediaSection, ptToCodecName) {\n    // NOTE(syerrapragada): In some cases Chrome produces an offer/answer\n    // with duplicate \"rtx\" payload mapping in media section. When applied,\n    // Chrome rejects the SDP. We workaround this by deleting duplicate\n    // \"rtx\" mappings found in SDP.\n    return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {\n        var rtpmapRegex = new RegExp(\"^a=rtpmap:\" + pt + \" rtx.+$\", 'gm');\n        return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {\n            var rtpmapRegex = new RegExp(\"\\r\\n\" + rtpmap);\n            var fmtpmapRegex = new RegExp(\"\\r\\na=fmtp:\" + pt + \" apt=[0-9]+\");\n            return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');\n        }, section);\n    }, mediaSection);\n}\n/**\n * @param {Map<PT, Codec>} ptToCodecName\n * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts\n */\nfunction createCodecNameToPts(ptToCodecName) {\n    var codecNameToPts = new Map();\n    ptToCodecName.forEach(function (codecName, pt) {\n        var pts = codecNameToPts.get(codecName) || new Set();\n        return codecNameToPts.set(codecName, pts.add(pt));\n    });\n    return codecNameToPts;\n}\n/**\n * @param {string} mediaSection\n * @param {Map<PT, Codec>} ptToCodecName\n * @param {Set<RtxPT>} rtxPts\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n */\nfunction createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {\n    return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {\n        var fmtpPattern = new RegExp(\"a=fmtp:\" + rtxPt + \" apt=(\\\\d+)\");\n        var matches = mediaSection.match(fmtpPattern);\n        if (!matches) {\n            invalidRtxPts.add(rtxPt);\n            return rtxPtToAssociatedPt;\n        }\n        var pt = Number.parseInt(matches[1]);\n        if (!ptToCodecName.has(pt)) {\n            // This is Issue 8329.\n            invalidRtxPts.add(rtxPt);\n            return rtxPtToAssociatedPt;\n        }\n        var codecName = ptToCodecName.get(pt);\n        if (codecName === 'rtx') {\n            // Strange\n            invalidRtxPts.add(rtxPt);\n            return rtxPtToAssociatedPt;\n        }\n        return rtxPtToAssociatedPt.set(rtxPt, pt);\n    }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt\n * @param {Set<RtxPT>} invalidRtxPts\n * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt\n */\nfunction createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {\n    // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.\n    var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {\n        var rtxPt = pair[0];\n        var pt = pair[1];\n        var rtxPts = associatedPtToRtxPts.get(pt) || new Set();\n        return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));\n    }, new Map());\n    // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the\n    // same NonRtxPT are removed and added to invalidRtxPts.\n    return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {\n        var pt = pair[0];\n        var rtxPts = Array.from(pair[1]);\n        if (rtxPts.length > 1) {\n            rtxPts.forEach(function (rtxPt) {\n                invalidRtxPts.add(rtxPt);\n            });\n            return associatedPtToRtxPt;\n        }\n        return associatedPtToRtxPt.set(pt, rtxPts[0]);\n    }, new Map());\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {\n    var pattern = new RegExp(\"a=fmtp:\" + rtxPt + \".*\\r\\n\", 'gm');\n    return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @returns {string} newMediaSection\n */\nfunction deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {\n    var pattern = new RegExp(\"a=rtpmap:\" + rtxPt + \".*\\r\\n\", 'gm');\n    return mediaSection.replace(pattern, '');\n}\n/**\n * @param {string} mediaSection\n * @param {RtxPT} rtxPt\n * @param {NonRtxPT} pt\n * @returns {string} newMediaSection\n */\nfunction addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {\n    return mediaSection.endsWith('\\r\\n')\n        ? mediaSection + \"a=fmtp:\" + rtxPt + \" apt=\" + pt + \"\\r\\n\"\n        : mediaSection + \"\\r\\na=fmtp:\" + rtxPt + \" apt=\" + pt;\n}\nmodule.exports = workaround;\n//# sourceMappingURL=issue8329.js.map"]},"metadata":{},"sourceType":"script"}
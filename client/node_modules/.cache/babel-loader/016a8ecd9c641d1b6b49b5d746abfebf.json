{"ast":null,"code":"'use strict';\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\n\nfunction delay(timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 0;\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n}\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\n\n\nfunction detectSilence(audioContext, stream, timeout) {\n  timeout = typeof timeout === 'number' ? timeout : 250;\n  var source = audioContext.createMediaStreamSource(stream);\n  var analyser = audioContext.createAnalyser();\n  analyser.fftSize = 2048;\n  source.connect(analyser);\n  var samples = new Uint8Array(analyser.fftSize);\n  var timeoutDidFire = false;\n  setTimeout(function () {\n    timeoutDidFire = true;\n  }, timeout);\n  /**\n   * We can't use async/await yet, so I need to factor this out.\n   * @returns {Promise<boolean>}\n   */\n\n  function doDetectSilence() {\n    if (timeoutDidFire) {\n      return Promise.resolve(true);\n    }\n\n    analyser.getByteTimeDomainData(samples); // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples\n    // being equal to 128 or all samples being equal to 0.\n\n    return samples.some(function (sample) {\n      return sample !== 128 && sample !== 0;\n    }) ? Promise.resolve(false) : delay().then(doDetectSilence);\n  }\n\n  return doDetectSilence().then(function (isSilent) {\n    source.disconnect();\n    return isSilent;\n  }, function (error) {\n    source.disconnect();\n    throw error;\n  });\n}\n\nmodule.exports = detectSilence;","map":{"version":3,"sources":["../../lib/webaudio/detectsilence.js"],"names":[],"mappings":"AAAA;AAEA;;;;AAIG;;AACH,SAAS,KAAT,CAAe,OAAf,EAAsB;AACpB,EAAA,OAAO,GAAG,OAAO,OAAP,KAAmB,QAAnB,GAA8B,OAA9B,GAAwC,CAAlD;AACA,SAAO,IAAI,OAAJ,CAAY,UAAA,OAAA,EAAO;AAAI,WAAA,UAAU,CAAC,OAAD,EAAV,OAAU,CAAV;AAA4B,GAAnD,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,SAAS,aAAT,CAAuB,YAAvB,EAAqC,MAArC,EAA6C,OAA7C,EAAoD;AAClD,EAAA,OAAO,GAAG,OAAO,OAAP,KAAmB,QAAnB,GAA8B,OAA9B,GAAwC,GAAlD;AAEA,MAAM,MAAM,GAAG,YAAY,CAAC,uBAAb,CAAqC,MAArC,CAAf;AACA,MAAM,QAAQ,GAAG,YAAY,CAAC,cAAb,EAAjB;AACA,EAAA,QAAQ,CAAC,OAAT,GAAmB,IAAnB;AACA,EAAA,MAAM,CAAC,OAAP,CAAe,QAAf;AAEA,MAAM,OAAO,GAAG,IAAI,UAAJ,CAAe,QAAQ,CAAC,OAAxB,CAAhB;AAEA,MAAI,cAAc,GAAG,KAArB;AACA,EAAA,UAAU,CAAC,YAAA;AAAQ,IAAA,cAAc,GAAG,IAAjB;AAAwB,GAAjC,EAAmC,OAAnC,CAAV;AAEA;;;AAGG;;AACH,WAAS,eAAT,GAAwB;AACtB,QAAI,cAAJ,EAAoB;AAClB,aAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AACD,IAAA,QAAQ,CAAC,qBAAT,CAA+B,OAA/B,EAJsB,CAKtB;AACA;;AACA,WAAO,OAAO,CAAC,IAAR,CAAa,UAAA,MAAA,EAAM;AAAI,aAAA,MAAM,KAAK,GAAX,IAAkB,MAAM,KAAxB,CAAA;AAA8B,KAArD,IACH,OAAO,CAAC,OAAR,CAAgB,KAAhB,CADG,GAEH,KAAK,GAAG,IAAR,CAAa,eAAb,CAFJ;AAGD;;AAED,SAAO,eAAe,GAAG,IAAlB,CAAuB,UAAA,QAAA,EAAQ;AACpC,IAAA,MAAM,CAAC,UAAP;AACA,WAAO,QAAP;AACD,GAHM,EAGJ,UAAA,KAAA,EAAK;AACN,IAAA,MAAM,CAAC,UAAP;AACA,UAAM,KAAN;AACD,GANM,CAAP;AAOD;;AAED,MAAM,CAAC,OAAP,GAAiB,aAAjB","sourceRoot":"","sourcesContent":["'use strict';\n/**\n * Return a Promise that resolves after `timeout` milliseconds.\n * @param {?number} [timeout=0]\n * @returns {Promise<void>}\n */\nfunction delay(timeout) {\n    timeout = typeof timeout === 'number' ? timeout : 0;\n    return new Promise(function (resolve) { return setTimeout(resolve, timeout); });\n}\n/**\n * Attempt to detect silence. The Promise returned by this function returns\n * false as soon as audio is detected or true after `timeout` milliseconds.\n * @param {AudioContext} audioContext\n * @param {MediaStream} stream\n * @param {?number} [timeout=250]\n * @returns {Promise<boolean>}\n */\nfunction detectSilence(audioContext, stream, timeout) {\n    timeout = typeof timeout === 'number' ? timeout : 250;\n    var source = audioContext.createMediaStreamSource(stream);\n    var analyser = audioContext.createAnalyser();\n    analyser.fftSize = 2048;\n    source.connect(analyser);\n    var samples = new Uint8Array(analyser.fftSize);\n    var timeoutDidFire = false;\n    setTimeout(function () { timeoutDidFire = true; }, timeout);\n    /**\n     * We can't use async/await yet, so I need to factor this out.\n     * @returns {Promise<boolean>}\n     */\n    function doDetectSilence() {\n        if (timeoutDidFire) {\n            return Promise.resolve(true);\n        }\n        analyser.getByteTimeDomainData(samples);\n        // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples\n        // being equal to 128 or all samples being equal to 0.\n        return samples.some(function (sample) { return sample !== 128 && sample !== 0; })\n            ? Promise.resolve(false)\n            : delay().then(doDetectSilence);\n    }\n    return doDetectSilence().then(function (isSilent) {\n        source.disconnect();\n        return isSilent;\n    }, function (error) {\n        source.disconnect();\n        throw error;\n    });\n}\nmodule.exports = detectSilence;\n//# sourceMappingURL=detectsilence.js.map"]},"metadata":{},"sourceType":"script"}
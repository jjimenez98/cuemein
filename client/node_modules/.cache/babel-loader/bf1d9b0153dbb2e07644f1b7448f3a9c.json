{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar getUserMedia = require('@twilio/webrtc').getUserMedia;\n\nvar _a = require('@twilio/webrtc/lib/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar _b = require('../../util'),\n    capitalize = _b.capitalize,\n    defer = _b.defer,\n    isUserMediaTrack = _b.isUserMediaTrack,\n    waitForSometime = _b.waitForSometime,\n    waitForEvent = _b.waitForEvent;\n\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\n\nvar detectSilentAudio = require('../../util/detectsilentaudio');\n\nvar detectSilentVideo = require('../../util/detectsilentvideo');\n\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\n\nvar MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#stopped\n   */\n  return function (_super) {\n    __extends(LocalMediaTrack, _super);\n    /**\n     * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n\n\n    function LocalMediaTrack(mediaStreamTrack, options) {\n      var _this = this; // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n      // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n      // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n\n\n      var workaroundWebKitBug1208516 = (guessBrowser() === 'safari' || isIOSChrome()) && isUserMediaTrack(mediaStreamTrack) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n      options = Object.assign({\n        getUserMedia: getUserMedia,\n        isCreatedByCreateLocalTracks: false,\n        workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n        gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n      }, options);\n      var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n      var kind = mediaTrackSender.kind;\n      _this = _super.call(this, mediaTrackSender, options) || this;\n      Object.defineProperties(_this, {\n        _constraints: {\n          value: typeof options[kind] === 'object' ? options[kind] : {},\n          writable: true\n        },\n        _getUserMedia: {\n          value: options.getUserMedia\n        },\n        _gUMSilentTrackWorkaround: {\n          value: options.gUMSilentTrackWorkaround\n        },\n        _workaroundWebKitBug1208516: {\n          value: options.workaroundWebKitBug1208516\n        },\n        _workaroundWebKitBug1208516Cleanup: {\n          value: null,\n          writable: true\n        },\n        _didCallEnd: {\n          value: false,\n          writable: true\n        },\n        _isCreatedByCreateLocalTracks: {\n          value: options.isCreatedByCreateLocalTracks\n        },\n        _trackSender: {\n          value: mediaTrackSender\n        },\n        id: {\n          enumerable: true,\n          value: mediaTrackSender.id\n        },\n        isEnabled: {\n          enumerable: true,\n          get: function get() {\n            return mediaTrackSender.enabled;\n          }\n        },\n        isStopped: {\n          enumerable: true,\n          get: function get() {\n            return mediaTrackSender.readyState === 'ended';\n          }\n        }\n      }); // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n      // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n\n      if (_this._workaroundWebKitBug1208516) {\n        _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n      }\n\n      return _this;\n    }\n    /**\n     * @private\n     */\n\n\n    LocalMediaTrack.prototype._end = function () {\n      if (this._didCallEnd) {\n        return;\n      }\n\n      _super.prototype._end.call(this);\n\n      this._didCallEnd = true;\n      this.emit('stopped', this);\n    };\n    /**\n     * @private\n     */\n\n\n    LocalMediaTrack.prototype._initialize = function () {\n      if (this._didCallEnd) {\n        this._didCallEnd = false;\n      }\n\n      _super.prototype._initialize.call(this);\n    };\n    /**\n     * @private\n     */\n\n\n    LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n      var _a;\n\n      var _b = this,\n          getUserMedia = _b._getUserMedia,\n          gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n          log = _b._log,\n          kind = _b.mediaStreamTrack.kind;\n\n      log.info('Re-acquiring the MediaStreamTrack');\n      log.debug('Constraints:', constraints);\n      var gUMConstraints = Object.assign({\n        audio: false,\n        video: false\n      }, (_a = {}, _a[kind] = constraints, _a));\n      var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n      return gUMPromise.then(function (mediaStream) {\n        return mediaStream.getTracks()[0];\n      });\n    };\n    /**\n     * @private\n     */\n\n\n    LocalMediaTrack.prototype._restart = function (constraints) {\n      var _this = this;\n\n      var log = this._log;\n      constraints = constraints || this._constraints; // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised in case of\n      // video, or the restarted audio will still be silent. Hence, we stop the\n      // MediaStreamTrack here.\n\n      this._stop();\n\n      return this._reacquireTrack(constraints).catch(function (error) {\n        log.error('Failed to re-acquire the MediaStreamTrack:', {\n          error: error,\n          constraints: constraints\n        });\n        throw error;\n      }).then(function (newMediaStreamTrack) {\n        log.info('Re-acquired the MediaStreamTrack');\n        log.debug('MediaStreamTrack:', newMediaStreamTrack);\n        _this._constraints = Object.assign({}, constraints);\n        return _this._setMediaStreamTrack(newMediaStreamTrack);\n      });\n    };\n    /**\n     * @private\n     */\n\n\n    LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n      var _this = this; // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n\n\n      mediaStreamTrack.enabled = this.mediaStreamTrack.enabled; // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n      // stopped, this should fire a \"stopped\" event.\n\n      this._stop(); // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n      // the processedTrack already set, we don't want to replace that.\n\n\n      return (this._unprocessedTrack ? Promise.resolve().then(function () {\n        _this._unprocessedTrack = mediaStreamTrack;\n      }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n        _this._log.warn('setMediaStreamTrack failed:', {\n          error: error,\n          mediaStreamTrack: mediaStreamTrack\n        });\n      })).then(function () {\n        _this._initialize();\n\n        _this._getAllAttachedElements().forEach(function (el) {\n          return _this._attach(el);\n        });\n      });\n    };\n    /**\n     * @private\n     */\n\n\n    LocalMediaTrack.prototype._stop = function () {\n      this.mediaStreamTrack.stop();\n\n      this._end();\n\n      return this;\n    };\n\n    LocalMediaTrack.prototype.enable = function (enabled) {\n      enabled = typeof enabled === 'boolean' ? enabled : true;\n\n      if (enabled !== this.mediaStreamTrack.enabled) {\n        this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n\n        this.mediaStreamTrack.enabled = enabled;\n        this.emit(enabled ? 'enabled' : 'disabled', this);\n      }\n\n      return this;\n    };\n\n    LocalMediaTrack.prototype.disable = function () {\n      return this.enable(false);\n    };\n\n    LocalMediaTrack.prototype.restart = function (constraints) {\n      var _this = this;\n\n      var kind = this.kind;\n\n      if (!this._isCreatedByCreateLocalTracks) {\n        return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n      }\n\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n\n      var promise = this._restart(constraints);\n\n      if (this._workaroundWebKitBug1208516) {\n        promise = promise.finally(function () {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        });\n      }\n\n      return promise;\n    };\n\n    LocalMediaTrack.prototype.stop = function () {\n      this._log.info('Stopping');\n\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n\n      return this._stop();\n    };\n\n    return LocalMediaTrack;\n  }(AudioOrVideoTrack);\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\n\n\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var el = localMediaTrack._dummyEl,\n      mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n  var trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again.\n      el.pause();\n    });\n  }\n\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n        isStopped = localMediaTrack.isStopped,\n        muted = localMediaTrack.mediaStreamTrack.muted;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup; // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        });\n      } // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n\n\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    });\n  }\n\n  function onMute() {\n    var log = localMediaTrack._log,\n        kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack); // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    mediaStreamTrack.addEventListener('ended', maybeRestart);\n    mediaStreamTrack.addEventListener('mute', onMute);\n    mediaStreamTrack.addEventListener('unmute', maybeRestart);\n  }\n\n  function removeMediaStreamTrackListeners() {\n    mediaStreamTrack.removeEventListener('ended', maybeRestart);\n    mediaStreamTrack.removeEventListener('mute', onMute);\n    mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n  } // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n\n\n  var onVisibilityChange = function onVisibilityChange(isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;","map":{"version":3,"sources":["../../../lib/media/track/localmediatrack.js"],"names":[],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEQ,IAAA,YAAY,GAAK,OAAO,CAAC,gBAAD,CAAP,CAAL,YAAZ;;AACF,IAAA,EAAA,GAAgC,OAAO,CAAC,yBAAD,CAAvC;AAAA,IAAE,YAAY,GAAA,EAAA,CAAA,YAAd;AAAA,IAAgB,WAAW,GAAA,EAAA,CAAA,WAA3B;;AAEA,IAAA,EAAA,GAAyE,OAAO,CAAC,YAAD,CAAhF;AAAA,IAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;AAAA,IAAc,KAAK,GAAA,EAAA,CAAA,KAAnB;AAAA,IAAqB,gBAAgB,GAAA,EAAA,CAAA,gBAArC;AAAA,IAAuC,eAAe,GAAA,EAAA,CAAA,eAAtD;AAAA,IAAwD,YAAY,GAAA,EAAA,CAAA,YAApE;;AACgB,IAAA,cAAc,GAAO,OAAO,CAAC,sBAAD,CAAP,CAA+B,UAA/B,CAAP,cAAd;;AACtB,IAAM,iBAAiB,GAAG,OAAO,CAAC,8BAAD,CAAjC;;AACA,IAAM,iBAAiB,GAAG,OAAO,CAAC,8BAAD,CAAjC;;AACA,IAAM,yBAAyB,GAAG,OAAO,CAAC,yCAAD,CAAzC;;AACA,IAAM,0BAA0B,GAAG,OAAO,CAAC,uCAAD,CAA1C;;AACA,IAAM,wBAAwB,GAAG,OAAO,CAAC,iCAAD,CAAxC;;AACA,IAAM,gBAAgB,GAAG,OAAO,CAAC,UAAD,CAAhC;;AAEA,SAAS,oBAAT,CAA8B,iBAA9B,EAA+C;AAC7C;;;;;;;AAOG;AACH,SAAA,UAAA,MAAA,EAAA;AAAqC,IAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;AACnC;;;;AAIG;;;AACH,aAAA,eAAA,CAAY,gBAAZ,EAA8B,OAA9B,EAAqC;AAArC,UAAA,KAAA,GAAA,IAAA,CAAqC,CACnC;AACA;AACA;;;AACA,UAAM,0BAA0B,GAAG,CAAC,YAAY,OAAO,QAAnB,IAA+B,WAAW,EAA3C,KAC9B,gBAAgB,CAAC,gBAAD,CADc,IAE9B,OAAO,QAAP,KAAoB,QAFU,IAG9B,OAAO,QAAQ,CAAC,gBAAhB,KAAqC,UAHP,IAI9B,OAAO,QAAQ,CAAC,eAAhB,KAAoC,QAJzC;AAMA,MAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc;AACtB,QAAA,YAAY,EAAA,YADU;AAEtB,QAAA,4BAA4B,EAAE,KAFR;AAGtB,QAAA,0BAA0B,EAAA,0BAHJ;AAItB,QAAA,wBAAwB,EAAA;AAJF,OAAd,EAKP,OALO,CAAV;AAOA,UAAM,gBAAgB,GAAG,IAAI,gBAAJ,CAAqB,gBAArB,CAAzB;AACQ,UAAA,IAAI,GAAK,gBAAgB,CAArB,IAAJ;AAER,MAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,gBAAN,EAAwB,OAAxB,KAAgC,IAAhC;AAEA,MAAA,MAAM,CAAC,gBAAP,CAAwB,KAAxB,EAA8B;AAC5B,QAAA,YAAY,EAAE;AACZ,UAAA,KAAK,EAAE,OAAO,OAAO,CAAC,IAAD,CAAd,KAAyB,QAAzB,GACH,OAAO,CAAC,IAAD,CADJ,GAEH,EAHQ;AAIZ,UAAA,QAAQ,EAAE;AAJE,SADc;AAO5B,QAAA,aAAa,EAAE;AACb,UAAA,KAAK,EAAE,OAAO,CAAC;AADF,SAPa;AAU5B,QAAA,yBAAyB,EAAE;AACzB,UAAA,KAAK,EAAE,OAAO,CAAC;AADU,SAVC;AAa5B,QAAA,2BAA2B,EAAE;AAC3B,UAAA,KAAK,EAAE,OAAO,CAAC;AADY,SAbD;AAgB5B,QAAA,kCAAkC,EAAE;AAClC,UAAA,KAAK,EAAE,IAD2B;AAElC,UAAA,QAAQ,EAAE;AAFwB,SAhBR;AAoB5B,QAAA,WAAW,EAAE;AACX,UAAA,KAAK,EAAE,KADI;AAEX,UAAA,QAAQ,EAAE;AAFC,SApBe;AAwB5B,QAAA,6BAA6B,EAAE;AAC7B,UAAA,KAAK,EAAE,OAAO,CAAC;AADc,SAxBH;AA2B5B,QAAA,YAAY,EAAE;AACZ,UAAA,KAAK,EAAE;AADK,SA3Bc;AA8B5B,QAAA,EAAE,EAAE;AACF,UAAA,UAAU,EAAE,IADV;AAEF,UAAA,KAAK,EAAE,gBAAgB,CAAC;AAFtB,SA9BwB;AAkC5B,QAAA,SAAS,EAAE;AACT,UAAA,UAAU,EAAE,IADH;AAET,UAAA,GAAG,EAAA,eAAA;AACD,mBAAO,gBAAgB,CAAC,OAAxB;AACD;AAJQ,SAlCiB;AAwC5B,QAAA,SAAS,EAAE;AACT,UAAA,UAAU,EAAE,IADH;AAET,UAAA,GAAG,EAAA,eAAA;AACD,mBAAO,gBAAgB,CAAC,UAAjB,KAAgC,OAAvC;AACD;AAJQ;AAxCiB,OAA9B,EAtBmC,CAsEnC;AACA;;AACA,UAAI,KAAI,CAAC,2BAAT,EAAsC;AACpC,QAAA,KAAI,CAAC,kCAAL,GAA0C,+BAA+B,CAAC,KAAD,CAAzE;AACD;;;AACF;AAED;;AAEG;;;AACH,IAAA,eAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,UAAI,KAAK,WAAT,EAAsB;AACpB;AACD;;AACD,MAAA,MAAA,CAAA,SAAA,CAAM,IAAN,CAAW,IAAX,CAAgB,IAAhB;;AACA,WAAK,WAAL,GAAmB,IAAnB;AACA,WAAK,IAAL,CAAU,SAAV,EAAqB,IAArB;AACD,KAPD;AASA;;AAEG;;;AACH,IAAA,eAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,UAAI,KAAK,WAAT,EAAsB;AACpB,aAAK,WAAL,GAAmB,KAAnB;AACD;;AACD,MAAA,MAAA,CAAA,SAAA,CAAM,WAAN,CAAkB,IAAlB,CAAuB,IAAvB;AACD,KALD;AAOA;;AAEG;;;AACH,IAAA,eAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,WAAhB,EAA2B;;;AACnB,UAAA,EAAA,GAKF,IALE;AAAA,UACW,YAAY,GAAA,EAAA,CAAA,aADvB;AAAA,UAEuB,wBAAwB,GAAA,EAAA,CAAA,yBAF/C;AAAA,UAGE,GAAG,GAAA,EAAA,CAAA,IAHL;AAAA,UAIgB,IAAI,GAAA,EAAA,CAAA,gBAAA,CAAA,IAJpB;;AAON,MAAA,GAAG,CAAC,IAAJ,CAAS,mCAAT;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,cAAV,EAA0B,WAA1B;AAEA,UAAM,cAAc,GAAG,MAAM,CAAC,MAAP,CAAc;AACnC,QAAA,KAAK,EAAE,KAD4B;AAEnC,QAAA,KAAK,EAAE;AAF4B,OAAd,GAGtB,EAAA,GAAA,EAAA,EAAI,EAAA,CAAC,IAAD,CAAA,GAAQ,WAAZ,EAAuB,EAHD,EAAvB;AAKA,UAAM,UAAU,GAAG,KAAK,kCAAL,GACf,wBAAwB,CAAC,GAAD,EAAM,YAAN,EAAoB,cAApB,CADT,GAEf,YAAY,CAAC,cAAD,CAFhB;AAIA,aAAO,UAAU,CAAC,IAAX,CAAgB,UAAA,WAAA,EAAW;AAChC,eAAO,WAAW,CAAC,SAAZ,GAAwB,CAAxB,CAAP;AACD,OAFM,CAAP;AAGD,KAvBD;AAyBA;;AAEG;;;AACH,IAAA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,WAAT,EAAoB;AAApB,UAAA,KAAA,GAAA,IAAA;;AACU,UAAM,GAAG,GAAK,KAAL,IAAT;AACR,MAAA,WAAW,GAAG,WAAW,IAAI,KAAK,YAAlC,CAFkB,CAIlB;AACA;AACA;AACA;;AACA,WAAK,KAAL;;AAEA,aAAO,KAAK,eAAL,CAAqB,WAArB,EAAkC,KAAlC,CAAwC,UAAA,KAAA,EAAK;AAClD,QAAA,GAAG,CAAC,KAAJ,CAAU,4CAAV,EAAwD;AAAE,UAAA,KAAK,EAAA,KAAP;AAAS,UAAA,WAAW,EAAA;AAApB,SAAxD;AACA,cAAM,KAAN;AACD,OAHM,EAGJ,IAHI,CAGC,UAAA,mBAAA,EAAmB;AACzB,QAAA,GAAG,CAAC,IAAJ,CAAS,kCAAT;AACA,QAAA,GAAG,CAAC,KAAJ,CAAU,mBAAV,EAA+B,mBAA/B;AACA,QAAA,KAAI,CAAC,YAAL,GAAoB,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,WAAlB,CAApB;AACA,eAAO,KAAI,CAAC,oBAAL,CAA0B,mBAA1B,CAAP;AACD,OARM,CAAP;AASD,KAnBD;AAqBA;;AAEG;;;AACH,IAAA,eAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,gBAArB,EAAqC;AAArC,UAAA,KAAA,GAAA,IAAA,CAAqC,CACnC;;;AACA,MAAA,gBAAgB,CAAC,OAAjB,GAA2B,KAAK,gBAAL,CAAsB,OAAjD,CAFmC,CAInC;AACA;;AACA,WAAK,KAAL,GANmC,CAQnC;AACA;;;AACA,aAAO,CAAC,KAAK,iBAAL,GAAyB,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,YAAA;AACtD,QAAA,KAAI,CAAC,iBAAL,GAAyB,gBAAzB;AACD,OAFgC,CAAzB,GAEH,KAAK,YAAL,CAAkB,mBAAlB,CAAsC,gBAAtC,EAAwD,KAAxD,CAA8D,UAAA,KAAA,EAAK;AACtE,QAAA,KAAI,CAAC,IAAL,CAAU,IAAV,CAAe,6BAAf,EAA8C;AAAE,UAAA,KAAK,EAAA,KAAP;AAAS,UAAA,gBAAgB,EAAA;AAAzB,SAA9C;AACD,OAFI,CAFE,EAIH,IAJG,CAIE,YAAA;AACP,QAAA,KAAI,CAAC,WAAL;;AACA,QAAA,KAAI,CAAC,uBAAL,GAA+B,OAA/B,CAAuC,UAAA,EAAA,EAAE;AAAI,iBAAA,KAAI,CAAC,OAAL,CAAA,EAAA,CAAA;AAAgB,SAA7D;AACD,OAPM,CAAP;AAQD,KAlBD;AAoBA;;AAEG;;;AACH,IAAA,eAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,WAAK,gBAAL,CAAsB,IAAtB;;AACA,WAAK,IAAL;;AACA,aAAO,IAAP;AACD,KAJD;;AAMA,IAAA,eAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,OAAP,EAAc;AACZ,MAAA,OAAO,GAAG,OAAO,OAAP,KAAmB,SAAnB,GAA+B,OAA/B,GAAyC,IAAnD;;AACA,UAAI,OAAO,KAAK,KAAK,gBAAL,CAAsB,OAAtC,EAA+C;AAC7C,aAAK,IAAL,CAAU,IAAV,CAAe,CAAG,OAAO,GAAG,IAAH,GAAU,KAApB,IAAyB,QAAxC;;AACA,aAAK,gBAAL,CAAsB,OAAtB,GAAgC,OAAhC;AACA,aAAK,IAAL,CAAU,OAAO,GAAG,SAAH,GAAe,UAAhC,EAA4C,IAA5C;AACD;;AACD,aAAO,IAAP;AACD,KARD;;AAUA,IAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,aAAO,KAAK,MAAL,CAAY,KAAZ,CAAP;AACD,KAFD;;AAIA,IAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,WAAR,EAAmB;AAAnB,UAAA,KAAA,GAAA,IAAA;;AACU,UAAA,IAAI,GAAK,KAAL,IAAJ;;AACR,UAAI,CAAC,KAAK,6BAAV,EAAyC;AACvC,eAAO,OAAO,CAAC,MAAR,CAAe,cAAc,CAAC,SAAD,EAAY,6BAC5C,WAAS,UAAU,CAAC,IAAD,CAAnB,GAAyB,+CADmB,KAE5C,oBAAkB,UAAU,CAAC,IAAD,CAA5B,GAAkC,QAFU,CAAZ,CAA7B,CAAP;AAGD;;AACD,UAAI,KAAK,kCAAT,EAA6C;AAC3C,aAAK,kCAAL;;AACA,aAAK,kCAAL,GAA0C,IAA1C;AACD;;AACD,UAAI,OAAO,GAAG,KAAK,QAAL,CAAc,WAAd,CAAd;;AAEA,UAAI,KAAK,2BAAT,EAAsC;AACpC,QAAA,OAAO,GAAG,OAAO,CAAC,OAAR,CAAgB,YAAA;AACxB,UAAA,KAAI,CAAC,kCAAL,GAA0C,+BAA+B,CAAC,KAAD,CAAzE;AACD,SAFS,CAAV;AAGD;;AACD,aAAO,OAAP;AACD,KAnBD;;AAqBA,IAAA,eAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,WAAK,IAAL,CAAU,IAAV,CAAe,UAAf;;AACA,UAAI,KAAK,kCAAT,EAA6C;AAC3C,aAAK,kCAAL;;AACA,aAAK,kCAAL,GAA0C,IAA1C;AACD;;AACD,aAAO,KAAK,KAAL,EAAP;AACD,KAPD;;AAQF,WAAA,eAAA;AAAC,GAxOD,CAAqC,iBAArC,CAAA;AAyOD;AAED;;;;;AAKG;;;AACH,SAAS,+BAAT,CAAyC,eAAzC,EAAwD;AAC9C,MAAM,GAAG,GAAW,eAAe,CAA1B,IAAT;AAAA,MAAW,IAAI,GAAK,eAAe,CAApB,IAAf;AACR,MAAM,aAAa,GAAG;AAAE,IAAA,KAAK,EAAE,iBAAT;AAA4B,IAAA,KAAK,EAAE;AAAnC,IAAuD,IAAvD,CAAtB;AAEM,MAAU,EAAE,GAAuB,eAAe,CAAtC,QAAZ;AAAA,MAAc,gBAAgB,GAAK,eAAe,CAApB,gBAA9B;AACN,MAAI,qBAAqB,GAAG,IAA5B;;AAEA,WAAS,YAAT,GAAqB;AACnB;AACA,WAAO,EAAE,CAAC,IAAH,GAAU,IAAV,CAAe,YAAA;AAAM,aAAA,aAAa,CAAb,EAAa,CAAb;AAAiB,KAAtC,EAAwC,IAAxC,CAA6C,UAAA,QAAA,EAAQ;AAC1D,UAAI,QAAJ,EAAc;AACZ,QAAA,GAAG,CAAC,IAAJ,CAAS,kBAAT;AACD,OAFD,MAEO;AACL,QAAA,GAAG,CAAC,IAAJ,CAAS,sBAAT;AACD;;AACD,aAAO,QAAP;AACD,KAPM,EAOJ,KAPI,CAOE,UAAA,KAAA,EAAK;AACZ,MAAA,GAAG,CAAC,IAAJ,CAAS,2BAAT,EAAsC,KAAtC;AACD,KATM,EASJ,OATI,CASI,YAAA;AACT;AACA,MAAA,EAAE,CAAC,KAAH;AACD,KAZM,CAAP;AAaD;;AAED,WAAS,oBAAT,GAA6B;AAEzB,QAAA,kCAAkC,GAGhC,eAAe,CAHiB,kCAAlC;AAAA,QACA,SAAS,GAEP,eAAe,CAFR,SADT;AAAA,QAEoB,KAAK,GACvB,eAAe,CAAA,gBAAf,CADuB,KAFzB;AAKF,QAAM,sBAAsB,GAAG,SAAS,IAAI,CAAC,CAAC,kCAA9C,CAP2B,CAS3B;AACA;AACA;AACA;;AACA,WAAO,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,YAAA;AAC5B,aAAO,QAAQ,CAAC,eAAT,KAA6B,SAA7B,IACF,CAAC,qBADC,KAED,KAAK,IAAI,sBAAT,IAAmC,YAAY,EAF9C,CAAP;AAGD,KAJM,CAAP;AAKD;;AAED,WAAS,YAAT,GAAqB;AACnB,WAAO,OAAO,CAAC,IAAR,CAAa,CAClB,YAAY,CAAC,gBAAD,EAAmB,QAAnB,CADM,EAElB,eAAe,CAAC,EAAD,CAFG,CAAb,EAGJ,IAHI,CAGC,YAAA;AAAM,aAAA,oBAAA,EAAA;AAAsB,KAH7B,EAG+B,IAH/B,CAGoC,UAAA,eAAA,EAAe;AACxD,UAAI,eAAe,IAAI,CAAC,qBAAxB,EAA+C;AAC7C,QAAA,qBAAqB,GAAG,KAAK,EAA7B;;AACA,QAAA,eAAe,CAAC,QAAhB,GAA2B,OAA3B,CAAmC,YAAA;AACjC,UAAA,EAAE,GAAG,eAAe,CAAC,QAArB;AACA,UAAA,+BAA+B;AAC/B,UAAA,gBAAgB,GAAG,eAAe,CAAC,gBAAnC;AACA,UAAA,4BAA4B;AAC5B,UAAA,qBAAqB,CAAC,OAAtB;AACA,UAAA,qBAAqB,GAAG,IAAxB;AACD,SAPD;AAQD,OAXuD,CAaxD;AACA;AACA;;;AACA,UAAM,OAAO,GAAI,qBAAqB,IAAI,qBAAqB,CAAC,OAAhD,IAA4D,OAAO,CAAC,OAAR,EAA5E;AACA,aAAO,OAAO,CAAC,OAAR,CAAgB,YAAA;AAAM,eAAA,0BAA0B,CAAC,eAA3B,CAAA,IAAA,CAAA;AAAgD,OAAtE,CAAP;AACD,KArBM,CAAP;AAsBD;;AAED,WAAS,MAAT,GAAe;AACL,QAAM,GAAG,GAAW,eAAe,CAA1B,IAAT;AAAA,QAAW,IAAI,GAAK,eAAe,CAApB,IAAf;AACR,IAAA,GAAG,CAAC,IAAJ,CAAS,OAAT;AACA,IAAA,GAAG,CAAC,KAAJ,CAAU,kBAAV,EAA8B,eAA9B,EAHa,CAKb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAA,0BAA0B,CAAC,aAA3B,CAAyC,IAAzC;AACD;;AAED,WAAS,4BAAT,GAAqC;AACnC,IAAA,gBAAgB,CAAC,gBAAjB,CAAkC,OAAlC,EAA2C,YAA3C;AACA,IAAA,gBAAgB,CAAC,gBAAjB,CAAkC,MAAlC,EAA0C,MAA1C;AACA,IAAA,gBAAgB,CAAC,gBAAjB,CAAkC,QAAlC,EAA4C,YAA5C;AACD;;AAED,WAAS,+BAAT,GAAwC;AACtC,IAAA,gBAAgB,CAAC,mBAAjB,CAAqC,OAArC,EAA8C,YAA9C;AACA,IAAA,gBAAgB,CAAC,mBAAjB,CAAqC,MAArC,EAA6C,MAA7C;AACA,IAAA,gBAAgB,CAAC,mBAAjB,CAAqC,QAArC,EAA+C,YAA/C;AACD,GA/FqD,CAiGtD;AACA;AACA;AACA;;;AACA,MAAI,kBAAkB,GAAG,SAArB,kBAAqB,CAAA,SAAA,EAAS;AAChC,WAAO,SAAS,GAAG,YAAY,EAAf,GAAoB,KAApC;AACD,GAFD;;AAGA,EAAA,yBAAyB,CAAC,kBAA1B,CAA6C,CAA7C,EAAgD,kBAAhD;AACA,EAAA,4BAA4B;AAE5B,SAAO,YAAA;AACL,IAAA,yBAAyB,CAAC,mBAA1B,CAA8C,CAA9C,EAAiD,kBAAjD;AACA,IAAA,+BAA+B;AAChC,GAHD;AAID;;AAED,MAAM,CAAC,OAAP,GAAiB,oBAAjB","sourceRoot":"","sourcesContent":["/* eslint new-cap:0 */\n'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar getUserMedia = require('@twilio/webrtc').getUserMedia;\nvar _a = require('@twilio/webrtc/lib/util'), guessBrowser = _a.guessBrowser, isIOSChrome = _a.isIOSChrome;\nvar _b = require('../../util'), capitalize = _b.capitalize, defer = _b.defer, isUserMediaTrack = _b.isUserMediaTrack, waitForSometime = _b.waitForSometime, waitForEvent = _b.waitForEvent;\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\nvar detectSilentAudio = require('../../util/detectsilentaudio');\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nvar MediaTrackSender = require('./sender');\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n    /**\n     * A {@link LocalMediaTrack} represents audio or video that your\n     * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n     * enabled and disabled with {@link LocalMediaTrack#enable} and\n     * {@link LocalMediaTrack#disable} or stopped completely with\n     * {@link LocalMediaTrack#stop}.\n     * @emits LocalMediaTrack#stopped\n     */\n    return /** @class */ (function (_super) {\n        __extends(LocalMediaTrack, _super);\n        /**\n         * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n         * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n         * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n         */\n        function LocalMediaTrack(mediaStreamTrack, options) {\n            var _this = this;\n            // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers\n            // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs\n            // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.\n            var workaroundWebKitBug1208516 = (guessBrowser() === 'safari' || isIOSChrome())\n                && isUserMediaTrack(mediaStreamTrack)\n                && typeof document === 'object'\n                && typeof document.addEventListener === 'function'\n                && typeof document.visibilityState === 'string';\n            options = Object.assign({\n                getUserMedia: getUserMedia,\n                isCreatedByCreateLocalTracks: false,\n                workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n                gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n            }, options);\n            var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n            var kind = mediaTrackSender.kind;\n            _this = _super.call(this, mediaTrackSender, options) || this;\n            Object.defineProperties(_this, {\n                _constraints: {\n                    value: typeof options[kind] === 'object'\n                        ? options[kind]\n                        : {},\n                    writable: true\n                },\n                _getUserMedia: {\n                    value: options.getUserMedia\n                },\n                _gUMSilentTrackWorkaround: {\n                    value: options.gUMSilentTrackWorkaround\n                },\n                _workaroundWebKitBug1208516: {\n                    value: options.workaroundWebKitBug1208516\n                },\n                _workaroundWebKitBug1208516Cleanup: {\n                    value: null,\n                    writable: true\n                },\n                _didCallEnd: {\n                    value: false,\n                    writable: true\n                },\n                _isCreatedByCreateLocalTracks: {\n                    value: options.isCreatedByCreateLocalTracks\n                },\n                _trackSender: {\n                    value: mediaTrackSender\n                },\n                id: {\n                    enumerable: true,\n                    value: mediaTrackSender.id\n                },\n                isEnabled: {\n                    enumerable: true,\n                    get: function () {\n                        return mediaTrackSender.enabled;\n                    }\n                },\n                isStopped: {\n                    enumerable: true,\n                    get: function () {\n                        return mediaTrackSender.readyState === 'ended';\n                    }\n                }\n            });\n            // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n            // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n            if (_this._workaroundWebKitBug1208516) {\n                _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n            }\n            return _this;\n        }\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._end = function () {\n            if (this._didCallEnd) {\n                return;\n            }\n            _super.prototype._end.call(this);\n            this._didCallEnd = true;\n            this.emit('stopped', this);\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._initialize = function () {\n            if (this._didCallEnd) {\n                this._didCallEnd = false;\n            }\n            _super.prototype._initialize.call(this);\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n            var _a;\n            var _b = this, getUserMedia = _b._getUserMedia, gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround, log = _b._log, kind = _b.mediaStreamTrack.kind;\n            log.info('Re-acquiring the MediaStreamTrack');\n            log.debug('Constraints:', constraints);\n            var gUMConstraints = Object.assign({\n                audio: false,\n                video: false\n            }, (_a = {}, _a[kind] = constraints, _a));\n            var gUMPromise = this._workaroundWebKitBug1208516Cleanup\n                ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)\n                : getUserMedia(gUMConstraints);\n            return gUMPromise.then(function (mediaStream) {\n                return mediaStream.getTracks()[0];\n            });\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._restart = function (constraints) {\n            var _this = this;\n            var log = this._log;\n            constraints = constraints || this._constraints;\n            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n            // without stopping it first, then a NotReadableError is raised in case of\n            // video, or the restarted audio will still be silent. Hence, we stop the\n            // MediaStreamTrack here.\n            this._stop();\n            return this._reacquireTrack(constraints).catch(function (error) {\n                log.error('Failed to re-acquire the MediaStreamTrack:', { error: error, constraints: constraints });\n                throw error;\n            }).then(function (newMediaStreamTrack) {\n                log.info('Re-acquired the MediaStreamTrack');\n                log.debug('MediaStreamTrack:', newMediaStreamTrack);\n                _this._constraints = Object.assign({}, constraints);\n                return _this._setMediaStreamTrack(newMediaStreamTrack);\n            });\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n            var _this = this;\n            // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n            mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n            // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n            // stopped, this should fire a \"stopped\" event.\n            this._stop();\n            // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n            // the processedTrack already set, we don't want to replace that.\n            return (this._unprocessedTrack ? Promise.resolve().then(function () {\n                _this._unprocessedTrack = mediaStreamTrack;\n            }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n                _this._log.warn('setMediaStreamTrack failed:', { error: error, mediaStreamTrack: mediaStreamTrack });\n            })).then(function () {\n                _this._initialize();\n                _this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });\n            });\n        };\n        /**\n         * @private\n         */\n        LocalMediaTrack.prototype._stop = function () {\n            this.mediaStreamTrack.stop();\n            this._end();\n            return this;\n        };\n        LocalMediaTrack.prototype.enable = function (enabled) {\n            enabled = typeof enabled === 'boolean' ? enabled : true;\n            if (enabled !== this.mediaStreamTrack.enabled) {\n                this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n                this.mediaStreamTrack.enabled = enabled;\n                this.emit(enabled ? 'enabled' : 'disabled', this);\n            }\n            return this;\n        };\n        LocalMediaTrack.prototype.disable = function () {\n            return this.enable(false);\n        };\n        LocalMediaTrack.prototype.restart = function (constraints) {\n            var _this = this;\n            var kind = this.kind;\n            if (!this._isCreatedByCreateLocalTracks) {\n                return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'\n                    + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\")\n                    + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n            }\n            if (this._workaroundWebKitBug1208516Cleanup) {\n                this._workaroundWebKitBug1208516Cleanup();\n                this._workaroundWebKitBug1208516Cleanup = null;\n            }\n            var promise = this._restart(constraints);\n            if (this._workaroundWebKitBug1208516) {\n                promise = promise.finally(function () {\n                    _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n                });\n            }\n            return promise;\n        };\n        LocalMediaTrack.prototype.stop = function () {\n            this._log.info('Stopping');\n            if (this._workaroundWebKitBug1208516Cleanup) {\n                this._workaroundWebKitBug1208516Cleanup();\n                this._workaroundWebKitBug1208516Cleanup = null;\n            }\n            return this._stop();\n        };\n        return LocalMediaTrack;\n    }(AudioOrVideoTrack));\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n    var log = localMediaTrack._log, kind = localMediaTrack.kind;\n    var detectSilence = { audio: detectSilentAudio, video: detectSilentVideo }[kind];\n    var el = localMediaTrack._dummyEl, mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n    var trackChangeInProgress = null;\n    function checkSilence() {\n        // The dummy element is paused, so play it and then detect silence.\n        return el.play().then(function () { return detectSilence(el); }).then(function (isSilent) {\n            if (isSilent) {\n                log.warn('Silence detected');\n            }\n            else {\n                log.info('Non-silence detected');\n            }\n            return isSilent;\n        }).catch(function (error) {\n            log.warn('Failed to detect silence:', error);\n        }).finally(function () {\n            // Pause the dummy element again.\n            el.pause();\n        });\n    }\n    function shouldReacquireTrack() {\n        var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup, isStopped = localMediaTrack.isStopped, muted = localMediaTrack.mediaStreamTrack.muted;\n        var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n        // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n        // 1. The app is foregrounded, and\n        // 2. A restart is not already in progress, and\n        // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n        return Promise.resolve().then(function () {\n            return document.visibilityState === 'visible'\n                && !trackChangeInProgress\n                && (muted || isInadvertentlyStopped || checkSilence());\n        });\n    }\n    function maybeRestart() {\n        return Promise.race([\n            waitForEvent(mediaStreamTrack, 'unmute'),\n            waitForSometime(50)\n        ]).then(function () { return shouldReacquireTrack(); }).then(function (shouldReacquire) {\n            if (shouldReacquire && !trackChangeInProgress) {\n                trackChangeInProgress = defer();\n                localMediaTrack._restart().finally(function () {\n                    el = localMediaTrack._dummyEl;\n                    removeMediaStreamTrackListeners();\n                    mediaStreamTrack = localMediaTrack.mediaStreamTrack;\n                    addMediaStreamTrackListeners();\n                    trackChangeInProgress.resolve();\n                    trackChangeInProgress = null;\n                });\n            }\n            // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n            // then this makes sure that visibility callback for phase 2 is called only\n            // after the MediaStreamTrack is re-acquired.\n            var promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();\n            return promise.finally(function () { return localMediaRestartDeferreds.resolveDeferred(kind); });\n        });\n    }\n    function onMute() {\n        var log = localMediaTrack._log, kind = localMediaTrack.kind;\n        log.info('Muted');\n        log.debug('LocalMediaTrack:', localMediaTrack);\n        // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n        // backgrounded, and the inadvertently paused elements are played before it\n        // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n        // setting this Deferred will make sure that the inadvertently paused elements\n        // are played only after the LocalMediaTrack is unmuted.\n        //\n        // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n        //\n        localMediaRestartDeferreds.startDeferred(kind);\n    }\n    function addMediaStreamTrackListeners() {\n        mediaStreamTrack.addEventListener('ended', maybeRestart);\n        mediaStreamTrack.addEventListener('mute', onMute);\n        mediaStreamTrack.addEventListener('unmute', maybeRestart);\n    }\n    function removeMediaStreamTrackListeners() {\n        mediaStreamTrack.removeEventListener('ended', maybeRestart);\n        mediaStreamTrack.removeEventListener('mute', onMute);\n        mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n    }\n    // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n    // this ensures that we acquire media tracks before RemoteMediaTrack\n    // tries to `play` them (in phase 2). This order is important because\n    // play can fail on safari if audio is not being captured.\n    var onVisibilityChange = function (isVisible) {\n        return isVisible ? maybeRestart() : false;\n    };\n    documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n    addMediaStreamTrackListeners();\n    return function () {\n        documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n        removeMediaStreamTrackListeners();\n    };\n}\nmodule.exports = mixinLocalMediaTrack;\n//# sourceMappingURL=localmediatrack.js.map"]},"metadata":{},"sourceType":"script"}
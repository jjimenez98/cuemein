{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar MediaTrack = require('./mediatrack');\n\nvar VideoProcessorEventObserver = require('./videoprocessoreventobserver');\n\nvar DEFAULT_FRAME_RATE = require('../../util/constants').DEFAULT_FRAME_RATE;\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\n\n\nvar VideoTrack = function (_super) {\n  __extends(VideoTrack, _super);\n  /**\n   * Construct a {@link VideoTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n\n\n  function VideoTrack(mediaTrackTransceiver, options) {\n    var _this = _super.call(this, mediaTrackTransceiver, options) || this;\n\n    Object.defineProperties(_this, {\n      _captureTimeoutId: {\n        value: null,\n        writable: true\n      },\n      _isCapturing: {\n        value: false,\n        writable: true\n      },\n      _inputFrame: {\n        value: null,\n        writable: true\n      },\n      _outputFrame: {\n        value: null,\n        writable: true\n      },\n      _processorEventObserver: {\n        value: null,\n        writable: true\n      },\n      _unmuteHandler: {\n        value: null,\n        writable: true\n      },\n      dimensions: {\n        enumerable: true,\n        value: {\n          width: null,\n          height: null\n        }\n      },\n      processor: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n    _this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(_this._log);\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {\n    if (isPublishing === void 0) {\n      isPublishing = false;\n    }\n\n    var canCaptureFrames = true;\n    var message = '';\n    var _a = this.mediaStreamTrack,\n        enabled = _a.enabled,\n        readyState = _a.readyState;\n\n    if (!enabled) {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is disabled';\n    }\n\n    if (readyState === 'ended') {\n      canCaptureFrames = false;\n      message = 'MediaStreamTrack is ended';\n    }\n\n    if (!this.processor) {\n      canCaptureFrames = false;\n      message = 'VideoProcessor not detected.';\n    }\n\n    if (!this._attachments.size && !isPublishing) {\n      canCaptureFrames = false;\n      message = 'VideoTrack is not publishing and there is no attached element.';\n    }\n\n    if (message) {\n      this._log.debug(message);\n    }\n\n    return {\n      canCaptureFrames: canCaptureFrames,\n      message: message\n    };\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._captureFrames = function () {\n    var _this = this;\n\n    if (this._isCapturing) {\n      this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n\n      return;\n    }\n\n    if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n      this._isCapturing = false;\n\n      this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n\n      return;\n    }\n\n    this._isCapturing = true;\n\n    this._processorEventObserver.emit('start');\n\n    this._log.debug('Start capturing frames');\n\n    var startTime = Date.now();\n    var processFramePeriodMs;\n\n    this._dummyEl.play().then(function () {\n      var captureFrame = function captureFrame(cb) {\n        clearTimeout(_this._captureTimeoutId);\n\n        var _a = _this.mediaStreamTrack.getSettings().frameRate,\n            frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;\n\n        var capturePeriodMs = Math.floor(1000 / frameRate);\n        var delay = capturePeriodMs - processFramePeriodMs;\n\n        if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n          delay = 0;\n        }\n\n        _this._captureTimeoutId = setTimeout(cb, delay);\n      };\n\n      var process = function process() {\n        var checkResult = _this._checkIfCanCaptureFrames();\n\n        if (!checkResult.canCaptureFrames) {\n          _this._isCapturing = false;\n\n          _this._processorEventObserver.emit('stop', checkResult.message);\n\n          _this._log.debug('Cannot capture frames. Stopping capturing frames.');\n\n          return;\n        }\n\n        startTime = Date.now();\n\n        var _a = _this.mediaStreamTrack.getSettings(),\n            _b = _a.width,\n            width = _b === void 0 ? 0 : _b,\n            _c = _a.height,\n            height = _c === void 0 ? 0 : _c; // Setting the canvas' dimension triggers a redraw.\n        // Only set it if it has changed.\n\n\n        if (_this._inputFrame.width !== width) {\n          _this._inputFrame.width = width;\n          _this._inputFrame.height = height;\n\n          if (_this._outputFrame) {\n            _this._outputFrame.width = width;\n            _this._outputFrame.height = height;\n          }\n        }\n\n        _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);\n\n        var result = null;\n\n        try {\n          result = _this.processor.processFrame(_this._inputFrame, _this._outputFrame);\n        } catch (ex) {\n          _this._log.debug('Exception detected after calling processFrame.', ex);\n        }\n\n        (result instanceof Promise ? result : Promise.resolve(result)).then(function () {\n          if (_this._outputFrame) {\n            _this.processedTrack.requestFrame();\n\n            _this._processorEventObserver.emit('stats');\n          }\n        }).finally(function () {\n          processFramePeriodMs = Date.now() - startTime;\n          captureFrame(process);\n        });\n      };\n\n      captureFrame(process);\n    }).catch(function (error) {\n      return _this._log.error('Video element cannot be played', {\n        error: error,\n        track: _this\n      });\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._initialize = function () {\n    var _this = this;\n\n    _super.prototype._initialize.call(this);\n\n    if (this._dummyEl) {\n      this._dummyEl.onloadedmetadata = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n        }\n      };\n\n      this._dummyEl.onresize = function () {\n        if (dimensionsChanged(_this, _this._dummyEl)) {\n          _this.dimensions.width = _this._dummyEl.videoWidth;\n          _this.dimensions.height = _this._dummyEl.videoHeight;\n\n          if (_this.isStarted) {\n            _this._log.debug('Dimensions changed:', _this.dimensions);\n\n            _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);\n          }\n        }\n      };\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._restartProcessor = function () {\n    var processor = this.processor;\n\n    if (processor) {\n      this.removeProcessor(processor);\n      this.addProcessor(processor);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  VideoTrack.prototype._start = function (dummyEl) {\n    this.dimensions.width = dummyEl.videoWidth;\n    this.dimensions.height = dummyEl.videoHeight;\n\n    this._log.debug('Dimensions:', this.dimensions);\n\n    return _super.prototype._start.call(this, dummyEl);\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n   * });\n   */\n\n\n  VideoTrack.prototype.addProcessor = function (processor) {\n    var _this = this;\n\n    if (typeof OffscreenCanvas !== 'function') {\n      return this._log.warn('Adding a VideoProcessor is not supported in this browser.');\n    }\n\n    if (!processor || typeof processor.processFrame !== 'function') {\n      throw new Error('Received an invalid VideoProcessor from addProcessor.');\n    }\n\n    if (this.processor) {\n      throw new Error('A VideoProcessor has already been added.');\n    }\n\n    if (!this._dummyEl) {\n      throw new Error('VideoTrack has not been initialized.');\n    }\n\n    this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n\n    if (!this._unmuteHandler) {\n      this._unmuteHandler = function () {\n        _this._log.debug('mediaStreamTrack unmuted'); // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n        // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n        // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n\n\n        if (_this.processedTrack.muted) {\n          _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n\n          _this._restartProcessor();\n        }\n      };\n\n      this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n    }\n\n    var _a = this.mediaStreamTrack.getSettings(),\n        _b = _a.width,\n        width = _b === void 0 ? 0 : _b,\n        _c = _a.height,\n        height = _c === void 0 ? 0 : _c,\n        _d = _a.frameRate,\n        frameRate = _d === void 0 ? DEFAULT_FRAME_RATE : _d;\n\n    this._inputFrame = new OffscreenCanvas(width, height);\n    this._outputFrame = document.createElement('canvas');\n    this._outputFrame.width = width;\n    this._outputFrame.height = height;\n    this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];\n    this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n    this.processor = processor;\n\n    this._processorEventObserver.emit('add', {\n      processor: processor,\n      captureHeight: height,\n      captureWidth: width,\n      inputFrameRate: frameRate,\n      isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')\n    });\n\n    this._updateElementsMediaStreamTrack();\n\n    this._captureFrames();\n\n    return this;\n  };\n  /**\n   * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n   *\n   * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n   * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n   *\n   * @returns {HTMLVideoElement} videoElement\n   * @example\n   * const Video = require('twilio-video');\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const videoElement = videoTrack.attach();\n   *   document.body.appendChild(videoElement);\n   * });\n  */\n\n  /**\n  * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n  * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n  *\n  * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n  * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n  * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n  * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n  * MediaStreamTracks of the same kind on the MediaStream, this method removes\n  * them.\n  *\n  * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * const Video = require('twilio-video');\n  *\n  * const videoElement = document.createElement('video');\n  * document.body.appendChild(videoElement);\n  *\n  * Video.createLocalVideoTrack().then(function(videoTrack) {\n  *   videoTrack.attach(videoElement);\n  * });\n  */\n\n  /**\n  * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n  * <code>document.querySelector</code>. The HTMLMediaElement could be an\n  * HTMLAudioElement or an HTMLVideoElement.\n  *\n  * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n  * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n  * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n  * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n  * MediaStreamTracks of the same kind on the MediaStream, this method removes\n  * them.\n  *\n  * @param {string} selector - A query selector for the HTMLMediaElement to\n  *   attach to\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * const Video = require('twilio-video');\n  *\n  * const videoElement = document.createElement('video');\n  * videoElement.id = 'my-video-element';\n  * document.body.appendChild(videoElement);\n  *\n  * Video.createLocalVideoTrack().then(function(track) {\n  *   track.attach('#my-video-element');\n  * });\n  */\n\n\n  VideoTrack.prototype.attach = function () {\n    var result = _super.prototype.attach.apply(this, arguments);\n\n    if (this.processor) {\n      this._captureFrames();\n    }\n\n    return result;\n  };\n  /**\n   * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n   * @returns {Array<HTMLMediaElement>} mediaElements\n   * @example\n   * const mediaElements = videoTrack.detach();\n   * mediaElements.forEach(mediaElement => mediaElement.remove());\n  */\n\n  /**\n  * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n  * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n  *   which the {@link VideoTrack} is attached\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * const videoElement = document.getElementById('my-video-element');\n  * videoTrack.detach(videoElement).remove();\n  */\n\n  /**\n  * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n  *   specified by <code>document.querySelector</code>.\n  * @param {string} selector - The query selector of HTMLMediaElement to which\n  *    the {@link VideoTrack} is attached\n  * @returns {HTMLMediaElement} mediaElement\n  * @example\n  * videoTrack.detach('#my-video-element').remove();\n  */\n\n\n  VideoTrack.prototype.detach = function () {\n    return _super.prototype.detach.apply(this, arguments);\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * Video.createLocalVideoTrack().then(function(videoTrack) {\n   *   const grayScaleProcessor = new GrayScaleProcessor(100);\n   *   videoTrack.addProcessor(grayScaleProcessor);\n   *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n   * });\n   */\n\n\n  VideoTrack.prototype.removeProcessor = function (processor) {\n    if (!processor) {\n      throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n    }\n\n    if (!this.processor) {\n      throw new Error('No existing VideoProcessor detected.');\n    }\n\n    if (processor !== this.processor) {\n      throw new Error('The provided VideoProcessor is different than the existing one.');\n    }\n\n    this._processorEventObserver.emit('remove');\n\n    this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n\n    clearTimeout(this._captureTimeoutId);\n    this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n    this._unmuteHandler = null;\n    this._isCapturing = false;\n    this.processor = null;\n    this.processedTrack = null;\n\n    this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);\n\n    this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);\n\n    this._inputFrame = null;\n    this._outputFrame = null;\n\n    this._updateElementsMediaStreamTrack();\n\n    return this;\n  };\n\n  return VideoTrack;\n}(MediaTrack);\n\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\n\nfunction dimensionsChanged(track, elem) {\n  return track.dimensions.width !== elem.videoWidth || track.dimensions.height !== elem.videoHeight;\n}\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\n\n\nmodule.exports = VideoTrack;","map":{"version":3,"sources":["../../../lib/media/track/videotrack.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MediaTrack = require('./mediatrack');\nvar VideoProcessorEventObserver = require('./videoprocessoreventobserver');\nvar DEFAULT_FRAME_RATE = require('../../util/constants').DEFAULT_FRAME_RATE;\n/**\n * A {@link VideoTrack} is a {@link Track} representing video.\n * @extends Track\n * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has\n *   started; if the {@link VideoTrack} started, there is enough video data to\n *   begin playback\n * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is\n *   enabled; if the {@link VideoTrack} is not enabled, it is \"paused\"\n * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s\n *   {@link VideoTrack.Dimensions}\n * @property {Track.Kind} kind - \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack\n * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.\n * It is null if no VideoProcessor has been added.\n * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently\n *   processing video frames. It is null if video frames are not being processed.\n * @emits VideoTrack#dimensionsChanged\n * @emits VideoTrack#disabled\n * @emits VideoTrack#enabled\n * @emits VideoTrack#started\n */\nvar VideoTrack = /** @class */ (function (_super) {\n    __extends(VideoTrack, _super);\n    /**\n     * Construct a {@link VideoTrack}.\n     * @param {MediaTrackTransceiver} mediaTrackTransceiver\n     * @param {{log: Log}} options\n     */\n    function VideoTrack(mediaTrackTransceiver, options) {\n        var _this = _super.call(this, mediaTrackTransceiver, options) || this;\n        Object.defineProperties(_this, {\n            _captureTimeoutId: {\n                value: null,\n                writable: true\n            },\n            _isCapturing: {\n                value: false,\n                writable: true\n            },\n            _inputFrame: {\n                value: null,\n                writable: true\n            },\n            _outputFrame: {\n                value: null,\n                writable: true\n            },\n            _processorEventObserver: {\n                value: null,\n                writable: true,\n            },\n            _unmuteHandler: {\n                value: null,\n                writable: true\n            },\n            dimensions: {\n                enumerable: true,\n                value: {\n                    width: null,\n                    height: null\n                }\n            },\n            processor: {\n                enumerable: true,\n                value: null,\n                writable: true\n            }\n        });\n        _this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(_this._log);\n        return _this;\n    }\n    /**\n     * @private\n     */\n    VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {\n        if (isPublishing === void 0) { isPublishing = false; }\n        var canCaptureFrames = true;\n        var message = '';\n        var _a = this.mediaStreamTrack, enabled = _a.enabled, readyState = _a.readyState;\n        if (!enabled) {\n            canCaptureFrames = false;\n            message = 'MediaStreamTrack is disabled';\n        }\n        if (readyState === 'ended') {\n            canCaptureFrames = false;\n            message = 'MediaStreamTrack is ended';\n        }\n        if (!this.processor) {\n            canCaptureFrames = false;\n            message = 'VideoProcessor not detected.';\n        }\n        if (!this._attachments.size && !isPublishing) {\n            canCaptureFrames = false;\n            message = 'VideoTrack is not publishing and there is no attached element.';\n        }\n        if (message) {\n            this._log.debug(message);\n        }\n        return { canCaptureFrames: canCaptureFrames, message: message };\n    };\n    /**\n     * @private\n     */\n    VideoTrack.prototype._captureFrames = function () {\n        var _this = this;\n        if (this._isCapturing) {\n            this._log.debug('Ignoring captureFrames call. Capture is already in progress');\n            return;\n        }\n        if (!this._checkIfCanCaptureFrames().canCaptureFrames) {\n            this._isCapturing = false;\n            this._log.debug('Cannot capture frames. Ignoring captureFrames call.');\n            return;\n        }\n        this._isCapturing = true;\n        this._processorEventObserver.emit('start');\n        this._log.debug('Start capturing frames');\n        var startTime = Date.now();\n        var processFramePeriodMs;\n        this._dummyEl.play().then(function () {\n            var captureFrame = function (cb) {\n                clearTimeout(_this._captureTimeoutId);\n                var _a = _this.mediaStreamTrack.getSettings().frameRate, frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;\n                var capturePeriodMs = Math.floor(1000 / frameRate);\n                var delay = capturePeriodMs - processFramePeriodMs;\n                if (delay < 0 || typeof processFramePeriodMs !== 'number') {\n                    delay = 0;\n                }\n                _this._captureTimeoutId = setTimeout(cb, delay);\n            };\n            var process = function () {\n                var checkResult = _this._checkIfCanCaptureFrames();\n                if (!checkResult.canCaptureFrames) {\n                    _this._isCapturing = false;\n                    _this._processorEventObserver.emit('stop', checkResult.message);\n                    _this._log.debug('Cannot capture frames. Stopping capturing frames.');\n                    return;\n                }\n                startTime = Date.now();\n                var _a = _this.mediaStreamTrack.getSettings(), _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c;\n                // Setting the canvas' dimension triggers a redraw.\n                // Only set it if it has changed.\n                if (_this._inputFrame.width !== width) {\n                    _this._inputFrame.width = width;\n                    _this._inputFrame.height = height;\n                    if (_this._outputFrame) {\n                        _this._outputFrame.width = width;\n                        _this._outputFrame.height = height;\n                    }\n                }\n                _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);\n                var result = null;\n                try {\n                    result = _this.processor.processFrame(_this._inputFrame, _this._outputFrame);\n                }\n                catch (ex) {\n                    _this._log.debug('Exception detected after calling processFrame.', ex);\n                }\n                ((result instanceof Promise) ? result : Promise.resolve(result))\n                    .then(function () {\n                    if (_this._outputFrame) {\n                        _this.processedTrack.requestFrame();\n                        _this._processorEventObserver.emit('stats');\n                    }\n                })\n                    .finally(function () {\n                    processFramePeriodMs = Date.now() - startTime;\n                    captureFrame(process);\n                });\n            };\n            captureFrame(process);\n        }).catch(function (error) { return _this._log.error('Video element cannot be played', { error: error, track: _this }); });\n    };\n    /**\n     * @private\n     */\n    VideoTrack.prototype._initialize = function () {\n        var _this = this;\n        _super.prototype._initialize.call(this);\n        if (this._dummyEl) {\n            this._dummyEl.onloadedmetadata = function () {\n                if (dimensionsChanged(_this, _this._dummyEl)) {\n                    _this.dimensions.width = _this._dummyEl.videoWidth;\n                    _this.dimensions.height = _this._dummyEl.videoHeight;\n                }\n            };\n            this._dummyEl.onresize = function () {\n                if (dimensionsChanged(_this, _this._dummyEl)) {\n                    _this.dimensions.width = _this._dummyEl.videoWidth;\n                    _this.dimensions.height = _this._dummyEl.videoHeight;\n                    if (_this.isStarted) {\n                        _this._log.debug('Dimensions changed:', _this.dimensions);\n                        _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);\n                    }\n                }\n            };\n        }\n    };\n    /**\n     * @private\n     */\n    VideoTrack.prototype._restartProcessor = function () {\n        var processor = this.processor;\n        if (processor) {\n            this.removeProcessor(processor);\n            this.addProcessor(processor);\n        }\n    };\n    /**\n     * @private\n     */\n    VideoTrack.prototype._start = function (dummyEl) {\n        this.dimensions.width = dummyEl.videoWidth;\n        this.dimensions.height = dummyEl.videoHeight;\n        this._log.debug('Dimensions:', this.dimensions);\n        return _super.prototype._start.call(this, dummyEl);\n    };\n    /**\n     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n     * @returns {this}\n     * @example\n     * class GrayScaleProcessor {\n     *   constructor(percentage) {\n     *     this.percentage = percentage;\n     *   }\n     *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n     *     const context = outputFrameBuffer.getContext('2d');\n     *     context.filter = `grayscale(${this.percentage}%)`;\n     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n     *   }\n     * }\n     *\n     * Video.createLocalVideoTrack().then(function(videoTrack) {\n     *   videoTrack.addProcessor(new GrayScaleProcessor(100));\n     * });\n     */\n    VideoTrack.prototype.addProcessor = function (processor) {\n        var _this = this;\n        if (typeof OffscreenCanvas !== 'function') {\n            return this._log.warn('Adding a VideoProcessor is not supported in this browser.');\n        }\n        if (!processor || typeof processor.processFrame !== 'function') {\n            throw new Error('Received an invalid VideoProcessor from addProcessor.');\n        }\n        if (this.processor) {\n            throw new Error('A VideoProcessor has already been added.');\n        }\n        if (!this._dummyEl) {\n            throw new Error('VideoTrack has not been initialized.');\n        }\n        this._log.debug('Adding VideoProcessor to the VideoTrack', processor);\n        if (!this._unmuteHandler) {\n            this._unmuteHandler = function () {\n                _this._log.debug('mediaStreamTrack unmuted');\n                // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,\n                // the processedTrack doesn't unmutes automatically although enabled is already set to true.\n                // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)\n                if (_this.processedTrack.muted) {\n                    _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');\n                    _this._restartProcessor();\n                }\n            };\n            this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);\n        }\n        var _a = this.mediaStreamTrack.getSettings(), _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c, _d = _a.frameRate, frameRate = _d === void 0 ? DEFAULT_FRAME_RATE : _d;\n        this._inputFrame = new OffscreenCanvas(width, height);\n        this._outputFrame = document.createElement('canvas');\n        this._outputFrame.width = width;\n        this._outputFrame.height = height;\n        this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];\n        this.processedTrack.enabled = this.mediaStreamTrack.enabled;\n        this.processor = processor;\n        this._processorEventObserver.emit('add', {\n            processor: processor,\n            captureHeight: height,\n            captureWidth: width,\n            inputFrameRate: frameRate,\n            isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')\n        });\n        this._updateElementsMediaStreamTrack();\n        this._captureFrames();\n        return this;\n    };\n    /**\n     * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.\n     *\n     * The HTMLVideoElement's <code>srcObject</code> will be set to a new\n     * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.\n     *\n     * @returns {HTMLVideoElement} videoElement\n     * @example\n     * const Video = require('twilio-video');\n     *\n     * Video.createLocalVideoTrack().then(function(videoTrack) {\n     *   const videoElement = videoTrack.attach();\n     *   document.body.appendChild(videoElement);\n     * });\n    */ /**\n     * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The\n     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.\n     *\n     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s\n     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n     * MediaStreamTracks of the same kind on the MediaStream, this method removes\n     * them.\n     *\n     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const Video = require('twilio-video');\n     *\n     * const videoElement = document.createElement('video');\n     * document.body.appendChild(videoElement);\n     *\n     * Video.createLocalVideoTrack().then(function(videoTrack) {\n     *   videoTrack.attach(videoElement);\n     * });\n    */ /**\n     * Attach the {@link VideoTrack} to an HTMLMediaElement selected by\n     * <code>document.querySelector</code>. The HTMLMediaElement could be an\n     * HTMLAudioElement or an HTMLVideoElement.\n     *\n     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,\n     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s\n     * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s\n     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other\n     * MediaStreamTracks of the same kind on the MediaStream, this method removes\n     * them.\n     *\n     * @param {string} selector - A query selector for the HTMLMediaElement to\n     *   attach to\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const Video = require('twilio-video');\n     *\n     * const videoElement = document.createElement('video');\n     * videoElement.id = 'my-video-element';\n     * document.body.appendChild(videoElement);\n     *\n     * Video.createLocalVideoTrack().then(function(track) {\n     *   track.attach('#my-video-element');\n     * });\n     */\n    VideoTrack.prototype.attach = function () {\n        var result = _super.prototype.attach.apply(this, arguments);\n        if (this.processor) {\n            this._captureFrames();\n        }\n        return result;\n    };\n    /**\n     * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.\n     * @returns {Array<HTMLMediaElement>} mediaElements\n     * @example\n     * const mediaElements = videoTrack.detach();\n     * mediaElements.forEach(mediaElement => mediaElement.remove());\n    */ /**\n     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.\n     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to\n     *   which the {@link VideoTrack} is attached\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * const videoElement = document.getElementById('my-video-element');\n     * videoTrack.detach(videoElement).remove();\n    */ /**\n     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement\n     *   specified by <code>document.querySelector</code>.\n     * @param {string} selector - The query selector of HTMLMediaElement to which\n     *    the {@link VideoTrack} is attached\n     * @returns {HTMLMediaElement} mediaElement\n     * @example\n     * videoTrack.detach('#my-video-element').remove();\n     */\n    VideoTrack.prototype.detach = function () {\n        return _super.prototype.detach.apply(this, arguments);\n    };\n    /**\n     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n     * @returns {this}\n     * @example\n     * class GrayScaleProcessor {\n     *   constructor(percentage) {\n     *     this.percentage = percentage;\n     *   }\n     *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n     *     const context = outputFrameBuffer.getContext('2d');\n     *     context.filter = `grayscale(${this.percentage}%)`;\n     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n     *   }\n     * }\n     *\n     * Video.createLocalVideoTrack().then(function(videoTrack) {\n     *   const grayScaleProcessor = new GrayScaleProcessor(100);\n     *   videoTrack.addProcessor(grayScaleProcessor);\n     *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);\n     * });\n     */\n    VideoTrack.prototype.removeProcessor = function (processor) {\n        if (!processor) {\n            throw new Error('Received an invalid VideoProcessor from removeProcessor.');\n        }\n        if (!this.processor) {\n            throw new Error('No existing VideoProcessor detected.');\n        }\n        if (processor !== this.processor) {\n            throw new Error('The provided VideoProcessor is different than the existing one.');\n        }\n        this._processorEventObserver.emit('remove');\n        this._log.debug('Removing VideoProcessor from the VideoTrack', processor);\n        clearTimeout(this._captureTimeoutId);\n        this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);\n        this._unmuteHandler = null;\n        this._isCapturing = false;\n        this.processor = null;\n        this.processedTrack = null;\n        this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);\n        this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);\n        this._inputFrame = null;\n        this._outputFrame = null;\n        this._updateElementsMediaStreamTrack();\n        return this;\n    };\n    return VideoTrack;\n}(MediaTrack));\nVideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';\nfunction dimensionsChanged(track, elem) {\n    return track.dimensions.width !== elem.videoWidth\n        || track.dimensions.height !== elem.videoHeight;\n}\n/**\n * A {@link VideoTrack}'s width and height.\n * @typedef {object} VideoTrack.Dimensions\n * @property {?number} width - The {@link VideoTrack}'s width or null if the\n *   {@link VideoTrack} has not yet started\n * @property {?number} height - The {@link VideoTrack}'s height or null if the\n *   {@link VideoTrack} has not yet started\n */\n/**\n * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},\n * is used to process incoming video frames before\n * sending to the encoder or renderer.\n * @typedef {object} VideoProcessor\n * @property {function} processFrame - A callback to receive input and output frame buffers for processing.\n * The input frame buffer contains the original video frame which can be used for additional processing\n * such as applying filters to it. The output frame buffer is used to receive the processed video frame\n * before sending to the encoder or renderer.\n *\n * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.\n * This callback has the following signature:<br/><br/>\n * <code>processFrame(</code><br/>\n * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>\n * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>\n * <code>): Promise&lt;void&gt; | void;</code>\n *\n * @example\n * class GrayScaleProcessor {\n *   constructor(percentage) {\n *     this.percentage = percentage;\n *   }\n *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n *     const context = outputFrameBuffer.getContext('2d');\n *     context.filter = `grayscale(${this.percentage}%)`;\n *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n *   }\n * }\n */\n/**\n * The {@link VideoTrack}'s dimensions changed.\n * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed\n * @event VideoTrack#dimensionsChanged\n */\n/**\n * The {@link VideoTrack} was disabled, i.e. \"paused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was disabled\n * @event VideoTrack#disabled\n */\n/**\n * The {@link VideoTrack} was enabled, i.e. \"unpaused\".\n * @param {VideoTrack} track - The {@link VideoTrack} that was enabled\n * @event VideoTrack#enabled\n */\n/**\n * The {@link VideoTrack} started. This means there is enough video data to\n * begin playback.\n * @param {VideoTrack} track - The {@link VideoTrack} that started\n * @event VideoTrack#started\n */\nmodule.exports = VideoTrack;\n//# sourceMappingURL=videotrack.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * A {@link QueueingEventEmitter} can queue events until a listener has been\n * added.\n * @extends EventEmitter\n */\n\n\nvar QueueingEventEmitter = function (_super) {\n  __extends(QueueingEventEmitter, _super);\n  /**\n   * Construct a {@link QueueingEventEmitter}\n   */\n\n\n  function QueueingEventEmitter() {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperties(_this, {\n      _queuedEvents: {\n        value: new Map()\n      }\n    });\n    return _this;\n  }\n  /**\n   * Emit any queued events.\n   * @returns {boolean} true if every event had listeners, false otherwise\n  */\n\n  /**\n  * Emit any queued events matching the event name.\n  * @param {string} event\n  * @returns {boolean} true if every event had listeners, false otherwise\n  */\n\n\n  QueueingEventEmitter.prototype.dequeue = function (event) {\n    var _this = this;\n\n    var result = true;\n\n    if (!event) {\n      this._queuedEvents.forEach(function (_, queuedEvent) {\n        result = this.dequeue(queuedEvent) && result;\n      }, this);\n\n      return result;\n    }\n\n    var queue = this._queuedEvents.get(event) || [];\n\n    this._queuedEvents.delete(event);\n\n    return queue.reduce(function (result, args) {\n      return _this.emit.apply(_this, __spreadArray([], __read([event].concat(args)))) && result;\n    }, result);\n  };\n  /**\n   * If the event has listeners, emit the event; otherwise, queue the event.\n   * @param {string} event\n   * @param {...*} args\n   * @returns {boolean} true if the event had listeners, false if the event was queued\n   */\n\n\n  QueueingEventEmitter.prototype.queue = function () {\n    var args = [].slice.call(arguments);\n\n    if (this.emit.apply(this, __spreadArray([], __read(args)))) {\n      return true;\n    }\n\n    var event = args[0];\n\n    if (!this._queuedEvents.has(event)) {\n      this._queuedEvents.set(event, []);\n    }\n\n    this._queuedEvents.get(event).push(args.slice(1));\n\n    return false;\n  };\n\n  return QueueingEventEmitter;\n}(EventEmitter);\n\nmodule.exports = QueueingEventEmitter;","map":{"version":3,"sources":["../lib/queueingeventemitter.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAM,YAAY,GAAG,OAAO,CAAC,QAAD,CAAP,CAAkB,YAAvC;AAEA;;;;AAIG;;;AACH,IAAA,oBAAA,GAAA,UAAA,MAAA,EAAA;AAAmC,EAAA,SAAA,CAAA,oBAAA,EAAA,MAAA,CAAA;AACjC;;AAEG;;;AACH,WAAA,oBAAA,GAAA;AAAA,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADT;;AAEE,IAAA,MAAM,CAAC,gBAAP,CAAwB,KAAxB,EAA8B;AAC5B,MAAA,aAAa,EAAE;AACb,QAAA,KAAK,EAAE,IAAI,GAAJ;AADM;AADa,KAA9B;;AAKD;AAED;;;AAGE;;AAAA;;;;AAIC;;;AACH,EAAA,oBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,KAAR,EAAa;AAAb,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,MAAM,GAAG,IAAb;;AACA,QAAI,CAAC,KAAL,EAAY;AACV,WAAK,aAAL,CAAmB,OAAnB,CAA2B,UAAS,CAAT,EAAY,WAAZ,EAAuB;AAChD,QAAA,MAAM,GAAG,KAAK,OAAL,CAAa,WAAb,KAA6B,MAAtC;AACD,OAFD,EAEG,IAFH;;AAGA,aAAO,MAAP;AACD;;AACD,QAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,GAAnB,CAAuB,KAAvB,KAAiC,EAA/C;;AACA,SAAK,aAAL,CAAmB,MAAnB,CAA0B,KAA1B;;AACA,WAAO,KAAK,CAAC,MAAN,CAAa,UAAC,MAAD,EAAS,IAAT,EAAa;AAAK,aAAA,KAAI,CAAC,IAAL,CAAS,KAAT,CAAA,KAAA,EAAI,aAAA,CAAA,EAAA,EAAA,MAAA,CAAS,CAAC,KAAD,EAAQ,MAAR,CAAe,IAAf,CAAT,CAAA,CAAJ,KAAA,MAAA;AAA4C,KAA3E,EAA6E,MAA7E,CAAP;AACD,GAXD;AAaA;;;;;AAKG;;;AACH,EAAA,oBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,QAAM,IAAI,GAAG,GAAG,KAAH,CAAS,IAAT,CAAc,SAAd,CAAb;;AACA,QAAI,KAAK,IAAL,CAAS,KAAT,CAAA,IAAA,EAAI,aAAA,CAAA,EAAA,EAAA,MAAA,CAAS,IAAT,CAAA,CAAJ,CAAJ,EAAwB;AACtB,aAAO,IAAP;AACD;;AACD,QAAM,KAAK,GAAG,IAAI,CAAC,CAAD,CAAlB;;AACA,QAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,KAAvB,CAAL,EAAoC;AAClC,WAAK,aAAL,CAAmB,GAAnB,CAAuB,KAAvB,EAA8B,EAA9B;AACD;;AACD,SAAK,aAAL,CAAmB,GAAnB,CAAuB,KAAvB,EAA8B,IAA9B,CAAmC,IAAI,CAAC,KAAL,CAAW,CAAX,CAAnC;;AACA,WAAO,KAAP;AACD,GAXD;;AAYF,SAAA,oBAAA;AAAC,CApDD,CAAmC,YAAnC,CAAA;;AAsDA,MAAM,CAAC,OAAP,GAAiB,oBAAjB","sourceRoot":"","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nvar EventEmitter = require('events').EventEmitter;\n/**\n * A {@link QueueingEventEmitter} can queue events until a listener has been\n * added.\n * @extends EventEmitter\n */\nvar QueueingEventEmitter = /** @class */ (function (_super) {\n    __extends(QueueingEventEmitter, _super);\n    /**\n     * Construct a {@link QueueingEventEmitter}\n     */\n    function QueueingEventEmitter() {\n        var _this = _super.call(this) || this;\n        Object.defineProperties(_this, {\n            _queuedEvents: {\n                value: new Map()\n            }\n        });\n        return _this;\n    }\n    /**\n     * Emit any queued events.\n     * @returns {boolean} true if every event had listeners, false otherwise\n    */ /**\n     * Emit any queued events matching the event name.\n     * @param {string} event\n     * @returns {boolean} true if every event had listeners, false otherwise\n     */\n    QueueingEventEmitter.prototype.dequeue = function (event) {\n        var _this = this;\n        var result = true;\n        if (!event) {\n            this._queuedEvents.forEach(function (_, queuedEvent) {\n                result = this.dequeue(queuedEvent) && result;\n            }, this);\n            return result;\n        }\n        var queue = this._queuedEvents.get(event) || [];\n        this._queuedEvents.delete(event);\n        return queue.reduce(function (result, args) { return _this.emit.apply(_this, __spreadArray([], __read([event].concat(args)))) && result; }, result);\n    };\n    /**\n     * If the event has listeners, emit the event; otherwise, queue the event.\n     * @param {string} event\n     * @param {...*} args\n     * @returns {boolean} true if the event had listeners, false if the event was queued\n     */\n    QueueingEventEmitter.prototype.queue = function () {\n        var args = [].slice.call(arguments);\n        if (this.emit.apply(this, __spreadArray([], __read(args)))) {\n            return true;\n        }\n        var event = args[0];\n        if (!this._queuedEvents.has(event)) {\n            this._queuedEvents.set(event, []);\n        }\n        this._queuedEvents.get(event).push(args.slice(1));\n        return false;\n    };\n    return QueueingEventEmitter;\n}(EventEmitter));\nmodule.exports = QueueingEventEmitter;\n//# sourceMappingURL=queueingeventemitter.js.map"]},"metadata":{},"sourceType":"script"}
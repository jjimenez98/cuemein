{"ast":null,"code":"'use strict';\n\nvar Filter = require('../../util/filter');\n/**\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\n * {@link IceBox} via {@link IceBox#update} are compared against previously\n * trickled candidates and only new candidates will be returned (assuming they\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\n * @property {?string} ufrag\n */\n\n\nvar IceBox = function () {\n  /**\n   * Construct an {@link IceBox}.\n   */\n  function IceBox() {\n    Object.defineProperties(this, {\n      _filter: {\n        value: new Filter({\n          getKey: function getKey(iceState) {\n            return iceState.ufrag;\n          },\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n            return a.revision <= b.revision;\n          }\n        })\n      },\n      _ufrag: {\n        writable: true,\n        value: null\n      },\n      ufrag: {\n        enumerable: true,\n        get: function get() {\n          return this._ufrag;\n        }\n      }\n    });\n  }\n  /**\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\n   * ICE candidates associated with the username fragment.\n   * @param {string} ufrag\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n\n\n  IceBox.prototype.setUfrag = function (ufrag) {\n    this._ufrag = ufrag;\n\n    var ice = this._filter.toMap().get(ufrag);\n\n    return ice ? ice.candidates : [];\n  };\n  /**\n   * Update the {@link IceBox}. This method returns any new ICE candidates\n   * associated with the current username fragment.\n   * @param {object} iceState\n   * @returns {Array<RTCIceCandidateInit>}\n   */\n\n\n  IceBox.prototype.update = function (iceState) {\n    // NOTE(mroberts): The Server sometimes does not set the candidates property.\n    iceState.candidates = iceState.candidates || [];\n\n    var oldIceState = this._filter.toMap().get(iceState.ufrag);\n\n    var oldCandidates = oldIceState ? oldIceState.candidates : [];\n    return this._filter.update(iceState) && this._ufrag === iceState.ufrag ? iceState.candidates.slice(oldCandidates.length) : [];\n  };\n\n  return IceBox;\n}();\n\nmodule.exports = IceBox;","map":{"version":3,"sources":["../../../lib/signaling/v2/icebox.js"],"names":[],"mappings":"AAAA;;AAEA,IAAM,MAAM,GAAG,OAAO,CAAC,mBAAD,CAAtB;AAEA;;;;;;AAMG;;;AACH,IAAA,MAAA,GAAA,YAAA;AACE;;AAEG;AACH,WAAA,MAAA,GAAA;AACE,IAAA,MAAM,CAAC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5B,MAAA,OAAO,EAAE;AACP,QAAA,KAAK,EAAE,IAAI,MAAJ,CAAW;AAChB,UAAA,MAAM,EAAE,SAAS,MAAT,CAAgB,QAAhB,EAAwB;AAC9B,mBAAO,QAAQ,CAAC,KAAhB;AACD,WAHe;AAIhB,UAAA,mBAAmB,EAAE,SAAS,mBAAT,CAA6B,CAA7B,EAAgC,CAAhC,EAAiC;AACpD,mBAAO,CAAC,CAAC,QAAF,IAAc,CAAC,CAAC,QAAvB;AACD;AANe,SAAX;AADA,OADmB;AAW5B,MAAA,MAAM,EAAE;AACN,QAAA,QAAQ,EAAE,IADJ;AAEN,QAAA,KAAK,EAAE;AAFD,OAXoB;AAe5B,MAAA,KAAK,EAAE;AACL,QAAA,UAAU,EAAE,IADP;AAEL,QAAA,GAAG,EAAA,eAAA;AACD,iBAAO,KAAK,MAAZ;AACD;AAJI;AAfqB,KAA9B;AAsBD;AAED;;;;;AAKG;;;AACH,EAAA,MAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,KAAT,EAAc;AACZ,SAAK,MAAL,GAAc,KAAd;;AACA,QAAM,GAAG,GAAG,KAAK,OAAL,CAAa,KAAb,GAAqB,GAArB,CAAyB,KAAzB,CAAZ;;AACA,WAAO,GAAG,GAAG,GAAG,CAAC,UAAP,GAAoB,EAA9B;AACD,GAJD;AAMA;;;;;AAKG;;;AACH,EAAA,MAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,QAAP,EAAe;AACb;AACA,IAAA,QAAQ,CAAC,UAAT,GAAsB,QAAQ,CAAC,UAAT,IAAuB,EAA7C;;AACA,QAAM,WAAW,GAAG,KAAK,OAAL,CAAa,KAAb,GAAqB,GAArB,CAAyB,QAAQ,CAAC,KAAlC,CAApB;;AACA,QAAM,aAAa,GAAG,WAAW,GAAG,WAAW,CAAC,UAAf,GAA4B,EAA7D;AACA,WAAO,KAAK,OAAL,CAAa,MAAb,CAAoB,QAApB,KAAiC,KAAK,MAAL,KAAgB,QAAQ,CAAC,KAA1D,GACH,QAAQ,CAAC,UAAT,CAAoB,KAApB,CAA0B,aAAa,CAAC,MAAxC,CADG,GAEH,EAFJ;AAGD,GARD;;AASF,SAAA,MAAA;AAAC,CAxDD,EAAA;;AA0DA,MAAM,CAAC,OAAP,GAAiB,MAAjB","sourceRoot":"","sourcesContent":["'use strict';\nvar Filter = require('../../util/filter');\n/**\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\n * {@link IceBox} via {@link IceBox#update} are compared against previously\n * trickled candidates and only new candidates will be returned (assuming they\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\n * @property {?string} ufrag\n */\nvar IceBox = /** @class */ (function () {\n    /**\n     * Construct an {@link IceBox}.\n     */\n    function IceBox() {\n        Object.defineProperties(this, {\n            _filter: {\n                value: new Filter({\n                    getKey: function getKey(iceState) {\n                        return iceState.ufrag;\n                    },\n                    isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n                        return a.revision <= b.revision;\n                    }\n                })\n            },\n            _ufrag: {\n                writable: true,\n                value: null\n            },\n            ufrag: {\n                enumerable: true,\n                get: function () {\n                    return this._ufrag;\n                }\n            }\n        });\n    }\n    /**\n     * Set the ICE username fragment on the {@link IceBox}. This method returns any\n     * ICE candidates associated with the username fragment.\n     * @param {string} ufrag\n     * @returns {Array<RTCIceCandidateInit>}\n     */\n    IceBox.prototype.setUfrag = function (ufrag) {\n        this._ufrag = ufrag;\n        var ice = this._filter.toMap().get(ufrag);\n        return ice ? ice.candidates : [];\n    };\n    /**\n     * Update the {@link IceBox}. This method returns any new ICE candidates\n     * associated with the current username fragment.\n     * @param {object} iceState\n     * @returns {Array<RTCIceCandidateInit>}\n     */\n    IceBox.prototype.update = function (iceState) {\n        // NOTE(mroberts): The Server sometimes does not set the candidates property.\n        iceState.candidates = iceState.candidates || [];\n        var oldIceState = this._filter.toMap().get(iceState.ufrag);\n        var oldCandidates = oldIceState ? oldIceState.candidates : [];\n        return this._filter.update(iceState) && this._ufrag === iceState.ufrag\n            ? iceState.candidates.slice(oldCandidates.length)\n            : [];\n    };\n    return IceBox;\n}());\nmodule.exports = IceBox;\n//# sourceMappingURL=icebox.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar _a = require('../'),\n    difference = _a.difference,\n    flatMap = _a.flatMap;\n\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n/**\n * A payload type\n * @typedef {number} PT\n */\n\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\n\nvar RTCP_BITRATE = 16000;\n/**\n * Construct a b= line string for the given max bitrate in bps. If the modifier\n * is 'AS', then the max bitrate will be converted to kbps using the formula\n * specified in the IETF spec for JSEP mentioned above.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\n *   otherwise return the constructed b= line string\n */\n\nfunction createBLine(modifier, maxBitrate) {\n  if (!maxBitrate) {\n    return null;\n  }\n\n  return \"\\r\\nb=\" + modifier + \":\" + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\n}\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\n\n\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\n\n\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\n\n\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp(\"a=rtpmap:\" + pt + \" ([^/]+)\");\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\n\n\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp(\"^a=fmtp:\" + pt + \" (.+)$\", 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _a = __read(nvPair.split('='), 2),\n        name = _a[0],\n        value = _a[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\n\n\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return \"m=\" + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp(\"m=\" + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp(\"a=\" + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\n\n\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0]; // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n\n  var matches = mLine.match(/([0-9]+)/g); // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n\n  if (!matches) {\n    return [];\n  } // Since only the Payload Types are needed, we discard the <port>.\n\n\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\n\n\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (_a) {\n    var codec = _a.codec;\n    return codec.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the specified max bitrate in the given m= section.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @param {string} section - m= section string\n * @returns {string} The updated m= section\n */\n\n\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n  var bLine = createBLine(modifier, maxBitrate) || '';\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n  var bLineMatched = section.match(bLinePattern);\n\n  if (!bLineMatched) {\n    return section.replace(/(\\r\\n)?$/, bLine + \"$1\");\n  }\n\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n  maxBitrate = maxBitrate || Infinity;\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n  return section.replace(bLinePattern, bLine);\n}\n/**\n * Set maximum bitrates to the media sections in a given sdp.\n * @param {string} sdp - sdp string\n * @param {string} modifier - 'AS' | 'TIAS\"\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\n *   if no limit is to be applied\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\n *   if no limit is to be applied\n * @returns {string} - The updated sdp string\n */\n\n\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Bitrate parameters should not be applied to m=application sections\n    // or to m=(audio|video) sections that do not receive media.\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\n  })).join('\\r\\n');\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\n\n\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\n\n\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {'planb' | 'unified'} sdpFormat\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\n\n\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n/**\n * Get the matching Payload Types in a unified plan m= section for a particular peer codec.\n * @param {Codec} peerCodec\n * @param {PT} peerPt\n * @param {Map<Codec, PT>} codecsToPts\n * @param {string} section\n * @param {string} peerSection\n * @returns {Array<PT>}\n */\n\n\nfunction unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingPts = codecsToPts.get(peerCodec) || [];\n\n  if (matchingPts.length <= 1) {\n    return matchingPts;\n  } // If there are no fmtp attributes for the codec in the peer m= section, then we\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\n  // Types.\n\n\n  var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n\n  if (!peerFmtpAttrs) {\n    return matchingPts;\n  } // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n\n\n  var matchingPt = matchingPts.find(function (pt) {\n    var fmtpAttrs = getFmtpAttributesForPt(pt, section);\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n    });\n  }); // If none of the matched Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the Payload Type that\n  // matches the peer fmtp attributes.\n\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n/**\n * Filter codecs in a unified plan m= section based on its peer m= section.\n * from the other peer.\n * @param {string} section\n * @param {Map<string, string>} peerMidsToMediaSections\n * @param {Array<string>} codecsToRemove\n * @returns {string}\n */\n\n\nfunction unifiedPlanFilterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n  // Do nothing if the m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(section)) {\n    return section;\n  } // Do nothing if the m= section does not have an equivalent remote m= section.\n\n\n  var mid = getMidForMediaSection(section);\n  var peerSection = mid && peerMidsToMediaSections.get(mid);\n\n  if (!peerSection) {\n    return section;\n  } // Construct a Map of the peer Payload Types to their codec names.\n\n\n  var peerPtToCodecs = createPtToCodecName(peerSection); // Construct a Map of the codec names to their Payload Types.\n\n  var codecsToPts = createCodecMapForMediaSection(section); // Maintain a list of non-rtx Payload Types to retain.\n\n  var pts = flatMap(Array.from(peerPtToCodecs), function (_a) {\n    var _b = __read(_a, 2),\n        peerPt = _b[0],\n        peerCodec = _b[1];\n\n    return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec) ? unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) : [];\n  }); // For each Payload Type that will be retained, retain their corresponding rtx\n  // Payload Type if present.\n\n  var rtxPts = codecsToPts.get('rtx') || []; // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n\n  pts = pts.concat(rtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n  })); // Filter out the below mentioned attribute lines in the m= section that do not\n  // belong to one of the Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n\n  var lines = section.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && pts.includes(parseInt(pt, 10));\n  }); // Filter the list of Payload Types in the first line of the m= section.\n\n  var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) {\n    return pts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n/**\n * Filter local codecs based on the remote unified plan SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\n\n\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return unifiedPlanFilterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n  })).join('\\r\\n');\n}\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @return {string} Updated SDP string\n */\n\n\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n  })).concat('').join('\\r\\n');\n}\n/**\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\n * corresponding local MediaStreamTrack IDs. These can be different when previously\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\n * SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\n\n\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _a) {\n    var _b = __read(_a, 2),\n        kind = _b[0],\n        trackIds = _b[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\n\n\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n\n\n    var mid = getMidForMediaSection(mediaSection);\n\n    if (!mid) {\n      return mediaSection;\n    } // In case there is no Track ID for the given MID in the map, do nothing.\n\n\n    var trackId = midsToTrackIds.get(mid);\n\n    if (!trackId) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n\n\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n\n    if (!attributes) {\n      return mediaSection;\n    } // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n\n    var _a = __read(attributes.split(' '), 2),\n        msid = _a[0],\n        trackIdToRewrite = _a[1];\n\n    var msidRegex = new RegExp(\"msid:\" + msid + (trackIdToRewrite ? \" \" + trackIdToRewrite : '') + \"$\", 'gm');\n    return mediaSection.replace(msidRegex, \"msid:\" + msid + \" \" + trackId);\n  })).join('\\r\\n');\n}\n/**\n * removes specified ssrc attributes from given sdp\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\n\n\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(function (line) {\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\n    });\n  }).join('\\r\\n');\n}\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\n\n\nfunction disableRtx(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    } // Create a map of codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(mediaSection); // Get the RTX payload types.\n\n    var rtxPts = codecsToPts.get('rtx'); // Do nothing if there are no RTX payload types.\n\n    if (!rtxPts) {\n      return mediaSection;\n    } // Remove the RTX payload types.\n\n\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(function (rtxPt) {\n      return pts.delete(rtxPt);\n    }); // Get the RTX SSRC.\n\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1]; // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp(\"^a=ssrc:\" + rtxSSRC + \" .+$\")] : []);\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\n      return filterRegexes.every(function (regex) {\n        return !regex.test(line);\n      });\n    }).join('\\r\\n'); // Reconstruct the m= section without the RTX payload types.\n\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\n\n\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_a) {\n    var _b = __read(_a, 2),\n        name = _b[0],\n        value = _b[1];\n\n    return name + \"=\" + value;\n  }).join(';');\n  return \"a=fmtp:\" + pt + \" \" + serializedFmtpAttrs;\n}\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\n\n\nfunction enableDtxForOpus(sdp, mids) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  mids = mids || mediaSections.filter(function (section) {\n    return /^m=audio/.test(section);\n  }).map(getMidForMediaSection);\n  return [session].concat(mediaSections.map(function (section) {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    } // Build a map codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(section); // Do nothing if a payload type for opus does not exist.\n\n    var opusPt = codecsToPts.get('opus');\n\n    if (!opusPt) {\n      return section;\n    } // If no fmtp attributes are found for opus, do nothing.\n\n\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n\n    if (!opusFmtpAttrs) {\n      return section;\n    } // Add usedtx=1 to the a=fmtp: line for opus.\n\n\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine); // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n\n    var mid = getMidForMediaSection(section);\n\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;","map":{"version":3,"sources":["../../../lib/util/sdp/index.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar _a = require('../'), difference = _a.difference, flatMap = _a.flatMap;\nvar setSimulcastInMediaSection = require('./simulcast');\nvar ptToFixedBitrateAudioCodecName = {\n    0: 'PCMU',\n    8: 'PCMA'\n};\n/**\n * A payload type\n * @typedef {number} PT\n */\n/**\n * An {@link AudioCodec} or {@link VideoCodec}\n * @typedef {AudioCodec|VideoCodec} Codec\n */\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\nvar RTCP_BITRATE = 16000;\n/**\n * Construct a b= line string for the given max bitrate in bps. If the modifier\n * is 'AS', then the max bitrate will be converted to kbps using the formula\n * specified in the IETF spec for JSEP mentioned above.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\n *   otherwise return the constructed b= line string\n */\nfunction createBLine(modifier, maxBitrate) {\n    if (!maxBitrate) {\n        return null;\n    }\n    return \"\\r\\nb=\" + modifier + \":\" + (modifier === 'AS'\n        ? Math.round((maxBitrate + RTCP_BITRATE) / 950)\n        : maxBitrate);\n}\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n    return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n        var pt = pair[0];\n        var codecName = pair[1];\n        var pts = codecMap.get(codecName) || [];\n        return codecMap.set(codecName, pts.concat(pt));\n    }, new Map());\n}\n/**\n * Create a Map of MIDs to m= sections for the given SDP.\n * @param {string} sdp\n * @returns {Map<string, string>}\n */\nfunction createMidToMediaSectionMap(sdp) {\n    return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n        var mid = getMidForMediaSection(mediaSection);\n        return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n    }, new Map());\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n    return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n        var rtpmapPattern = new RegExp(\"a=rtpmap:\" + pt + \" ([^/]+)\");\n        var matches = mediaSection.match(rtpmapPattern);\n        var codecName = matches\n            ? matches[1].toLowerCase()\n            : ptToFixedBitrateAudioCodecName[pt]\n                ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()\n                : '';\n        return ptToCodecName.set(pt, codecName);\n    }, new Map());\n}\n/**\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\n * @param {PT} pt\n * @param {string} mediaSection\n * @returns {?object}\n */\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n    // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n    // profile parameters expressed as name/value pairs separated by \";\".\n    var fmtpRegex = new RegExp(\"^a=fmtp:\" + pt + \" (.+)$\", 'm');\n    var matches = mediaSection.match(fmtpRegex);\n    return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n        var _a = __read(nvPair.split('='), 2), name = _a[0], value = _a[1];\n        attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n        return attrs;\n    }, {});\n}\n/**\n * Get the MID for the given m= section.\n * @param {string} mediaSection\n * @return {?string}\n */\nfunction getMidForMediaSection(mediaSection) {\n    // In \"a=mid:<mid>\", the regex matches <mid>.\n    var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n    return midMatches && midMatches[1];\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n    return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) { return \"m=\" + mediaSection; }).filter(function (mediaSection) {\n        var kindPattern = new RegExp(\"m=\" + (kind || '.*'), 'gm');\n        var directionPattern = new RegExp(\"a=\" + (direction || '.*'), 'gm');\n        return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n    });\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n    var mLine = section.split('\\r\\n')[0];\n    // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n    // the regex matches <port> and the Payload Types.\n    var matches = mLine.match(/([0-9]+)/g);\n    // This should not happen, but in case there are no Payload Types in\n    // the m= line, return an empty array.\n    if (!matches) {\n        return [];\n    }\n    // Since only the Payload Types are needed, we discard the <port>.\n    return matches.slice(1).map(function (match) { return parseInt(match, 10); });\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n    preferredCodecs = preferredCodecs.map(function (_a) {\n        var codec = _a.codec;\n        return codec.toLowerCase();\n    });\n    var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) { return codecMap.get(codecName) || []; });\n    var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n    var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) { return codecMap.get(codecName); });\n    return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the specified max bitrate in the given m= section.\n * @param {string} modifier - 'AS' | 'TIAS'\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\n * @param {string} section - m= section string\n * @returns {string} The updated m= section\n */\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n    var bLine = createBLine(modifier, maxBitrate) || '';\n    var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n    var bLineMatched = section.match(bLinePattern);\n    if (!bLineMatched) {\n        return section.replace(/(\\r\\n)?$/, bLine + \"$1\");\n    }\n    var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n    maxBitrate = maxBitrate || Infinity;\n    bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n    return section.replace(bLinePattern, bLine);\n}\n/**\n * Set maximum bitrates to the media sections in a given sdp.\n * @param {string} sdp - sdp string\n * @param {string} modifier - 'AS' | 'TIAS\"\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\n *   if no limit is to be applied\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\n *   if no limit is to be applied\n * @returns {string} - The updated sdp string\n */\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    return [session].concat(mediaSections.map(function (section) {\n        // Bitrate parameters should not be applied to m=application sections\n        // or to m=(audio|video) sections that do not receive media.\n        if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n            return section;\n        }\n        var kind = section.match(/^m=(audio|video)/)[1];\n        var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n        return setBitrateInMediaSection(modifier, maxBitrate, section);\n    })).join('\\r\\n');\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n    var lines = section.split('\\r\\n');\n    var mLine = lines[0];\n    var otherLines = lines.slice(1);\n    mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n    return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\n *   existing order of video codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    return [session].concat(mediaSections.map(function (section) {\n        // Codec preferences should not be applied to m=application sections.\n        if (!/^m=(audio|video)/.test(section)) {\n            return section;\n        }\n        var kind = section.match(/^m=(audio|video)/)[1];\n        var codecMap = createCodecMapForMediaSection(section);\n        var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n        var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n        var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n        var pcmaPayloadTypes = codecMap.get('pcma') || [];\n        var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n        var fixedBitratePayloadTypes = kind === 'audio'\n            ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))\n            : new Set();\n        return fixedBitratePayloadTypes.has(payloadTypes[0])\n            ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '')\n            : newSection;\n    })).join('\\r\\n');\n}\n/**\n * Return a new SDP string with simulcast settings.\n * @param {string} sdp\n * @param {'planb' | 'unified'} sdpFormat\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\n * @returns {string} Updated SDP string\n */\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    return [session].concat(mediaSections.map(function (section) {\n        section = section.replace(/\\r\\n$/, '');\n        if (!/^m=video/.test(section)) {\n            return section;\n        }\n        var codecMap = createCodecMapForMediaSection(section);\n        var payloadTypes = getPayloadTypesInMediaSection(section);\n        var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n        var hasVP8PayloadType = payloadTypes.some(function (payloadType) { return vp8PayloadTypes.has(payloadType); });\n        return hasVP8PayloadType\n            ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes)\n            : section;\n    })).concat('').join('\\r\\n');\n}\n/**\n * Get the matching Payload Types in a unified plan m= section for a particular peer codec.\n * @param {Codec} peerCodec\n * @param {PT} peerPt\n * @param {Map<Codec, PT>} codecsToPts\n * @param {string} section\n * @param {string} peerSection\n * @returns {Array<PT>}\n */\nfunction unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n    // If there is at most one local Payload Type that matches the remote codec, retain it.\n    var matchingPts = codecsToPts.get(peerCodec) || [];\n    if (matchingPts.length <= 1) {\n        return matchingPts;\n    }\n    // If there are no fmtp attributes for the codec in the peer m= section, then we\n    // cannot get a match in the  m= section. In that case, retain all matching Payload\n    // Types.\n    var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n    if (!peerFmtpAttrs) {\n        return matchingPts;\n    }\n    // Among the matched local Payload Types, find the one that matches the remote\n    // fmtp attributes.\n    var matchingPt = matchingPts.find(function (pt) {\n        var fmtpAttrs = getFmtpAttributesForPt(pt, section);\n        return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {\n            return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n        });\n    });\n    // If none of the matched Payload Types also have matching fmtp attributes,\n    // then retain all of them, otherwise retain only the Payload Type that\n    // matches the peer fmtp attributes.\n    return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n/**\n * Filter codecs in a unified plan m= section based on its peer m= section.\n * from the other peer.\n * @param {string} section\n * @param {Map<string, string>} peerMidsToMediaSections\n * @param {Array<string>} codecsToRemove\n * @returns {string}\n */\nfunction unifiedPlanFilterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(section)) {\n        return section;\n    }\n    // Do nothing if the m= section does not have an equivalent remote m= section.\n    var mid = getMidForMediaSection(section);\n    var peerSection = mid && peerMidsToMediaSections.get(mid);\n    if (!peerSection) {\n        return section;\n    }\n    // Construct a Map of the peer Payload Types to their codec names.\n    var peerPtToCodecs = createPtToCodecName(peerSection);\n    // Construct a Map of the codec names to their Payload Types.\n    var codecsToPts = createCodecMapForMediaSection(section);\n    // Maintain a list of non-rtx Payload Types to retain.\n    var pts = flatMap(Array.from(peerPtToCodecs), function (_a) {\n        var _b = __read(_a, 2), peerPt = _b[0], peerCodec = _b[1];\n        return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec)\n            ? unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection)\n            : [];\n    });\n    // For each Payload Type that will be retained, retain their corresponding rtx\n    // Payload Type if present.\n    var rtxPts = codecsToPts.get('rtx') || [];\n    // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n    pts = pts.concat(rtxPts.filter(function (rtxPt) {\n        var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n        return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n    }));\n    // Filter out the below mentioned attribute lines in the m= section that do not\n    // belong to one of the Payload Types that are to be retained.\n    // 1. \"a=rtpmap:<pt> <codec>\"\n    // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n    // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n    var lines = section.split('\\r\\n').filter(function (line) {\n        var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n        var pt = ptMatches && ptMatches[2];\n        return !ptMatches || (pt && pts.includes(parseInt(pt, 10)));\n    });\n    // Filter the list of Payload Types in the first line of the m= section.\n    var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) { return pts.includes(pt); });\n    return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n/**\n * Filter local codecs based on the remote unified plan SDP.\n * @param {string} localSdp\n * @param {string} remoteSdp\n * @returns {string} - Updated local SDP\n */\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n    var localMediaSections = getMediaSections(localSdp);\n    var localSession = localSdp.split('\\r\\nm=')[0];\n    var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n    return [localSession].concat(localMediaSections.map(function (localSection) {\n        return unifiedPlanFilterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n    })).join('\\r\\n');\n}\n/**\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\n * @param localSdp - simulcast enabled local sdp\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\n * @param remoteSdp - remote sdp\n * @return {string} Updated SDP string\n */\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n    var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n    var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n    var mediaSections = getMediaSections(localSdp);\n    var session = localSdp.split('\\r\\nm=')[0];\n    return [session].concat(mediaSections.map(function (section) {\n        section = section.replace(/\\r\\n$/, '');\n        if (!/^m=video/.test(section)) {\n            return section;\n        }\n        var midMatches = section.match(/^a=mid:(.+)$/m);\n        var mid = midMatches && midMatches[1];\n        if (!mid) {\n            return section;\n        }\n        var remoteSection = remoteMidToMediaSections.get(mid);\n        var remotePtToCodecs = createPtToCodecName(remoteSection);\n        var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n        var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n        return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n    })).concat('').join('\\r\\n');\n}\n/**\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\n * corresponding local MediaStreamTrack IDs. These can be different when previously\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\n * SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\n * @returns {string}\n */\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n    // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n    // present after the m= sections for the existing MediaStreamTracks, in order\n    // of addition.\n    var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _a) {\n        var _b = __read(_a, 2), kind = _b[0], trackIds = _b[1];\n        var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n        var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) { return !activeMidsToTrackIds.has(mid); });\n        newMids.forEach(function (mid, i) { return midsToTrackIds.set(mid, trackIds[i]); });\n        return midsToTrackIds;\n    }, new Map());\n    return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\n * @param {string} sdp\n * @param {Map<string, Track.ID>} midsToTrackIds\n * @returns {string}\n */\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    return [session].concat(mediaSections.map(function (mediaSection) {\n        // Do nothing if the m= section represents neither audio nor video.\n        if (!/^m=(audio|video)/.test(mediaSection)) {\n            return mediaSection;\n        }\n        // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n        var mid = getMidForMediaSection(mediaSection);\n        if (!mid) {\n            return mediaSection;\n        }\n        // In case there is no Track ID for the given MID in the map, do nothing.\n        var trackId = midsToTrackIds.get(mid);\n        if (!trackId) {\n            return mediaSection;\n        }\n        // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n        var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n        if (!attributes) {\n            return mediaSection;\n        }\n        // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n        // otherwise append the Track ID.\n        var _a = __read(attributes.split(' '), 2), msid = _a[0], trackIdToRewrite = _a[1];\n        var msidRegex = new RegExp(\"msid:\" + msid + (trackIdToRewrite ? \" \" + trackIdToRewrite : '') + \"$\", 'gm');\n        return mediaSection.replace(msidRegex, \"msid:\" + msid + \" \" + trackId);\n    })).join('\\r\\n');\n}\n/**\n * removes specified ssrc attributes from given sdp\n * @param {string} sdp\n * @param {Array<string>} ssrcAttributesToRemove\n * @returns {string}\n */\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n    return sdp.split('\\r\\n').filter(function (line) {\n        return !ssrcAttributesToRemove.find(function (srcAttribute) { return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line); });\n    }).join('\\r\\n');\n}\n/**\n * Disable RTX in a given sdp.\n * @param {string} sdp\n * @returns {string} sdp without RTX\n */\nfunction disableRtx(sdp) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    return [session].concat(mediaSections.map(function (mediaSection) {\n        // Do nothing if the m= section does not represent a video track.\n        if (!/^m=video/.test(mediaSection)) {\n            return mediaSection;\n        }\n        // Create a map of codecs to payload types.\n        var codecsToPts = createCodecMapForMediaSection(mediaSection);\n        // Get the RTX payload types.\n        var rtxPts = codecsToPts.get('rtx');\n        // Do nothing if there are no RTX payload types.\n        if (!rtxPts) {\n            return mediaSection;\n        }\n        // Remove the RTX payload types.\n        var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n        rtxPts.forEach(function (rtxPt) { return pts.delete(rtxPt); });\n        // Get the RTX SSRC.\n        var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n        var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];\n        // Remove the following lines associated with the RTX payload types:\n        // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n        // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n        // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n        // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n        var filterRegexes = [\n            /^a=fmtp:.+ apt=.+$/,\n            /^a=rtpmap:.+ rtx\\/.+$/,\n            /^a=ssrc-group:.+$/\n        ].concat(rtxSSRC\n            ? [new RegExp(\"^a=ssrc:\" + rtxSSRC + \" .+$\")]\n            : []);\n        mediaSection = mediaSection.split('\\r\\n')\n            .filter(function (line) { return filterRegexes.every(function (regex) { return !regex.test(line); }); })\n            .join('\\r\\n');\n        // Reconstruct the m= section without the RTX payload types.\n        return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n    })).join('\\r\\n');\n}\n/**\n * Generate an a=fmtp: line from the given payload type and attributes.\n * @param {PT} pt\n * @param {*} fmtpAttrs\n * @returns {string}\n */\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n    var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_a) {\n        var _b = __read(_a, 2), name = _b[0], value = _b[1];\n        return name + \"=\" + value;\n    }).join(';');\n    return \"a=fmtp:\" + pt + \" \" + serializedFmtpAttrs;\n}\n/**\n * Enable DTX for opus in the m= sections for the given MIDs.`\n * @param {string} sdp\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\n *   audio m= lines.\n * @returns {string}\n */\nfunction enableDtxForOpus(sdp, mids) {\n    var mediaSections = getMediaSections(sdp);\n    var session = sdp.split('\\r\\nm=')[0];\n    mids = mids || mediaSections\n        .filter(function (section) { return /^m=audio/.test(section); })\n        .map(getMidForMediaSection);\n    return [session].concat(mediaSections.map(function (section) {\n        // Do nothing if the m= section is not audio.\n        if (!/^m=audio/.test(section)) {\n            return section;\n        }\n        // Build a map codecs to payload types.\n        var codecsToPts = createCodecMapForMediaSection(section);\n        // Do nothing if a payload type for opus does not exist.\n        var opusPt = codecsToPts.get('opus');\n        if (!opusPt) {\n            return section;\n        }\n        // If no fmtp attributes are found for opus, do nothing.\n        var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n        if (!opusFmtpAttrs) {\n            return section;\n        }\n        // Add usedtx=1 to the a=fmtp: line for opus.\n        var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n        var origOpusFmtpRegex = new RegExp(origOpusFmtpLine);\n        // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n        var mid = getMidForMediaSection(section);\n        if (mids.includes(mid)) {\n            opusFmtpAttrs.usedtx = 1;\n        }\n        else {\n            delete opusFmtpAttrs.usedtx;\n        }\n        var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n        return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n    })).join('\\r\\n');\n}\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}
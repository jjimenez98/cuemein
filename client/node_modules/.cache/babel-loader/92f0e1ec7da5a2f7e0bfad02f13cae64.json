{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar AudioTrack = require('./audiotrack');\n\nvar mixinLocalMediaTrack = require('./localmediatrack');\n\nvar LocalMediaAudioTrack = mixinLocalMediaTrack(AudioTrack);\n/**\n * A {@link LocalAudioTrack} is an {@link AudioTrack} representing audio that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalAudioTrack#enable} and\n * {@link LocalAudioTrack#disable} or stopped completely with\n * {@link LocalAudioTrack#stop}.\n * @extends AudioTrack\n * @property {Track.ID} id - The {@link LocalAudioTrack}'s ID\n * @property {boolean} isStopped - Whether or not the {@link LocalAudioTrack} is\n *   stopped\n * @emits LocalAudioTrack#disabled\n * @emits LocalAudioTrack#enabled\n * @emits LocalAudioTrack#started\n * @emits LocalAudioTrack#stopped\n */\n\nvar LocalAudioTrack = function (_super) {\n  __extends(LocalAudioTrack, _super);\n  /**\n   * Construct a {@link LocalAudioTrack} from a MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack\n   * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n   */\n\n\n  function LocalAudioTrack(mediaStreamTrack, options) {\n    return _super.call(this, mediaStreamTrack, options) || this;\n  }\n\n  LocalAudioTrack.prototype.toString = function () {\n    return \"[LocalAudioTrack #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n\n  LocalAudioTrack.prototype.attach = function (el) {\n    el = _super.prototype.attach.call(this, el);\n    el.muted = true;\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  LocalAudioTrack.prototype._end = function () {\n    return _super.prototype._end.apply(this, arguments);\n  };\n  /**\n   * Disable the {@link LocalAudioTrack}. This is effectively \"mute\".\n   * @returns {this}\n   * @fires LocalAudioTrack#disabled\n   */\n\n\n  LocalAudioTrack.prototype.disable = function () {\n    return _super.prototype.disable.apply(this, arguments);\n  };\n  /**\n   * Enable the {@link LocalAudioTrack}. This is effectively \"unmute\".\n   * @returns {this}\n   * @fires LocalAudioTrack#enabled\n  */\n\n  /**\n  * Enable or disable the {@link LocalAudioTrack}. This is effectively \"unmute\"\n  * or \"mute\".\n  * @param {boolean} [enabled] - Specify false to mute the\n  *   {@link LocalAudioTrack}\n  * @returns {this}\n  * @fires LocalAudioTrack#disabled\n  * @fires LocalAudioTrack#enabled\n  */\n\n\n  LocalAudioTrack.prototype.enable = function () {\n    return _super.prototype.enable.apply(this, arguments);\n  };\n  /**\n   * Restart the {@link LocalAudioTrack}. This stops the existing MediaStreamTrack\n   * and creates a new MediaStreamTrack. If the {@link LocalAudioTrack} is being published\n   * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n   * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n   * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n   * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n   * the {@link LocalAudioTrack}'s ID is no longer guaranteed to be the same as the\n   * underlying MediaStreamTrack's ID.\n   * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n   *   for restarting the {@link LocalAudioTrack}; If not specified, then the current MediaTrackConstraints\n   *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n   *   will be used\n   * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalAudioTrack} was not created\n   *   using an one of <code>createLocalAudioTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n   *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n   *   raised by <code>getUserMedia</code> when it fails\n   * @fires LocalAudioTrack#stopped\n   * @fires LocalAudioTrack#started\n   * @example\n   * const { connect, createLocalAudioTrack } = require('twilio-video');\n   *\n   * // Create a LocalAudioTrack that captures audio from a USB microphone.\n   * createLocalAudioTrack({ deviceId: 'usb-mic-id' }).then(function(localAudioTrack) {\n   *   return connect('token', {\n   *     name: 'my-cool-room',\n   *     tracks: [localAudioTrack]\n   *   });\n   * }).then(function(room) {\n   *   // Restart the LocalAudioTrack to capture audio from the default microphone.\n   *   const localAudioTrack = Array.from(room.localParticipant.audioTracks.values())[0].track;\n   *   return localAudioTrack.restart({ deviceId: 'default-mic-id' });\n   * });\n   */\n\n\n  LocalAudioTrack.prototype.restart = function () {\n    return _super.prototype.restart.apply(this, arguments);\n  };\n  /**\n   * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n   * {@link LocalAudioTrack}, you should unpublish it after stopping.\n   * @returns {this}\n   * @fires LocalAudioTrack#stopped\n   */\n\n\n  LocalAudioTrack.prototype.stop = function () {\n    return _super.prototype.stop.apply(this, arguments);\n  };\n\n  return LocalAudioTrack;\n}(LocalMediaAudioTrack);\n/**\n * The {@link LocalAudioTrack} was disabled, i.e. \"muted\".\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was\n *   disabled\n * @event LocalAudioTrack#disabled\n */\n\n/**\n * The {@link LocalAudioTrack} was enabled, i.e. \"unmuted\".\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was enabled\n * @event LocalAudioTrack#enabled\n */\n\n/**\n * The {@link LocalAudioTrack} started. This means there is enough audio data to\n * begin playback.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that started\n * @event LocalAudioTrack#started\n */\n\n/**\n * The {@link LocalAudioTrack} stopped, either because {@link LocalAudioTrack#stop}\n * or {@link LocalAudioTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that stopped\n * @event LocalAudioTrack#stopped\n */\n\n\nmodule.exports = LocalAudioTrack;","map":{"version":3,"sources":["../../../lib/media/track/localaudiotrack.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAM,UAAU,GAAG,OAAO,CAAC,cAAD,CAA1B;;AACA,IAAM,oBAAoB,GAAG,OAAO,CAAC,mBAAD,CAApC;;AAEA,IAAM,oBAAoB,GAAG,oBAAoB,CAAC,UAAD,CAAjD;AAEA;;;;;;;;;;;;;;AAcG;;AACH,IAAA,eAAA,GAAA,UAAA,MAAA,EAAA;AAA8B,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;AAC5B;;;;AAIG;;;AACH,WAAA,eAAA,CAAY,gBAAZ,EAA8B,OAA9B,EAAqC;WACnC,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,gBAAN,EAAwB,OAAxB,KAAgC,I;AACjC;;AAED,EAAA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,uBAAqB,KAAK,WAA1B,GAAqC,IAArC,GAA0C,KAAK,EAA/C,GAAiD,GAAxD;AACD,GAFD;;AAIA,EAAA,eAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,EAAP,EAAS;AACP,IAAA,EAAE,GAAG,MAAA,CAAA,SAAA,CAAM,MAAN,CAAa,IAAb,CAAkB,IAAlB,EAAwB,EAAxB,CAAL;AACA,IAAA,EAAE,CAAC,KAAH,GAAW,IAAX;AACA,WAAO,EAAP;AACD,GAJD;AAMA;;AAEG;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,WAAO,MAAA,CAAA,SAAA,CAAM,IAAN,CAAW,KAAX,CAAiB,IAAjB,EAAuB,SAAvB,CAAP;AACD,GAFD;AAIA;;;;AAIG;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,WAAO,MAAA,CAAA,SAAA,CAAM,OAAN,CAAc,KAAd,CAAoB,IAApB,EAA0B,SAA1B,CAAP;AACD,GAFD;AAIA;;;;AAIE;;AAAA;;;;;;;;AAQC;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACE,WAAO,MAAA,CAAA,SAAA,CAAM,MAAN,CAAa,KAAb,CAAmB,IAAnB,EAAyB,SAAzB,CAAP;AACD,GAFD;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCG;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,WAAO,MAAA,CAAA,SAAA,CAAM,OAAN,CAAc,KAAd,CAAoB,IAApB,EAA0B,SAA1B,CAAP;AACD,GAFD;AAIA;;;;;AAKG;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,WAAO,MAAA,CAAA,SAAA,CAAM,IAAN,CAAW,KAAX,CAAiB,IAAjB,EAAuB,SAAvB,CAAP;AACD,GAFD;;AAGF,SAAA,eAAA;AAAC,CApGD,CAA8B,oBAA9B,CAAA;AAsGA;;;;;AAKG;;AAEH;;;;AAIG;;AAEH;;;;;AAKG;;AAEH;;;;;;AAMG;;;AAEH,MAAM,CAAC,OAAP,GAAiB,eAAjB","sourceRoot":"","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar AudioTrack = require('./audiotrack');\nvar mixinLocalMediaTrack = require('./localmediatrack');\nvar LocalMediaAudioTrack = mixinLocalMediaTrack(AudioTrack);\n/**\n * A {@link LocalAudioTrack} is an {@link AudioTrack} representing audio that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalAudioTrack#enable} and\n * {@link LocalAudioTrack#disable} or stopped completely with\n * {@link LocalAudioTrack#stop}.\n * @extends AudioTrack\n * @property {Track.ID} id - The {@link LocalAudioTrack}'s ID\n * @property {boolean} isStopped - Whether or not the {@link LocalAudioTrack} is\n *   stopped\n * @emits LocalAudioTrack#disabled\n * @emits LocalAudioTrack#enabled\n * @emits LocalAudioTrack#started\n * @emits LocalAudioTrack#stopped\n */\nvar LocalAudioTrack = /** @class */ (function (_super) {\n    __extends(LocalAudioTrack, _super);\n    /**\n     * Construct a {@link LocalAudioTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    function LocalAudioTrack(mediaStreamTrack, options) {\n        return _super.call(this, mediaStreamTrack, options) || this;\n    }\n    LocalAudioTrack.prototype.toString = function () {\n        return \"[LocalAudioTrack #\" + this._instanceId + \": \" + this.id + \"]\";\n    };\n    LocalAudioTrack.prototype.attach = function (el) {\n        el = _super.prototype.attach.call(this, el);\n        el.muted = true;\n        return el;\n    };\n    /**\n     * @private\n     */\n    LocalAudioTrack.prototype._end = function () {\n        return _super.prototype._end.apply(this, arguments);\n    };\n    /**\n     * Disable the {@link LocalAudioTrack}. This is effectively \"mute\".\n     * @returns {this}\n     * @fires LocalAudioTrack#disabled\n     */\n    LocalAudioTrack.prototype.disable = function () {\n        return _super.prototype.disable.apply(this, arguments);\n    };\n    /**\n     * Enable the {@link LocalAudioTrack}. This is effectively \"unmute\".\n     * @returns {this}\n     * @fires LocalAudioTrack#enabled\n    */ /**\n     * Enable or disable the {@link LocalAudioTrack}. This is effectively \"unmute\"\n     * or \"mute\".\n     * @param {boolean} [enabled] - Specify false to mute the\n     *   {@link LocalAudioTrack}\n     * @returns {this}\n     * @fires LocalAudioTrack#disabled\n     * @fires LocalAudioTrack#enabled\n     */\n    LocalAudioTrack.prototype.enable = function () {\n        return _super.prototype.enable.apply(this, arguments);\n    };\n    /**\n     * Restart the {@link LocalAudioTrack}. This stops the existing MediaStreamTrack\n     * and creates a new MediaStreamTrack. If the {@link LocalAudioTrack} is being published\n     * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n     * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n     * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n     * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n     * the {@link LocalAudioTrack}'s ID is no longer guaranteed to be the same as the\n     * underlying MediaStreamTrack's ID.\n     * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n     *   for restarting the {@link LocalAudioTrack}; If not specified, then the current MediaTrackConstraints\n     *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n     *   will be used\n     * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalAudioTrack} was not created\n     *   using an one of <code>createLocalAudioTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n     *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n     *   raised by <code>getUserMedia</code> when it fails\n     * @fires LocalAudioTrack#stopped\n     * @fires LocalAudioTrack#started\n     * @example\n     * const { connect, createLocalAudioTrack } = require('twilio-video');\n     *\n     * // Create a LocalAudioTrack that captures audio from a USB microphone.\n     * createLocalAudioTrack({ deviceId: 'usb-mic-id' }).then(function(localAudioTrack) {\n     *   return connect('token', {\n     *     name: 'my-cool-room',\n     *     tracks: [localAudioTrack]\n     *   });\n     * }).then(function(room) {\n     *   // Restart the LocalAudioTrack to capture audio from the default microphone.\n     *   const localAudioTrack = Array.from(room.localParticipant.audioTracks.values())[0].track;\n     *   return localAudioTrack.restart({ deviceId: 'default-mic-id' });\n     * });\n     */\n    LocalAudioTrack.prototype.restart = function () {\n        return _super.prototype.restart.apply(this, arguments);\n    };\n    /**\n     * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n     * {@link LocalAudioTrack}, you should unpublish it after stopping.\n     * @returns {this}\n     * @fires LocalAudioTrack#stopped\n     */\n    LocalAudioTrack.prototype.stop = function () {\n        return _super.prototype.stop.apply(this, arguments);\n    };\n    return LocalAudioTrack;\n}(LocalMediaAudioTrack));\n/**\n * The {@link LocalAudioTrack} was disabled, i.e. \"muted\".\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was\n *   disabled\n * @event LocalAudioTrack#disabled\n */\n/**\n * The {@link LocalAudioTrack} was enabled, i.e. \"unmuted\".\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was enabled\n * @event LocalAudioTrack#enabled\n */\n/**\n * The {@link LocalAudioTrack} started. This means there is enough audio data to\n * begin playback.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that started\n * @event LocalAudioTrack#started\n */\n/**\n * The {@link LocalAudioTrack} stopped, either because {@link LocalAudioTrack#stop}\n * or {@link LocalAudioTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that stopped\n * @event LocalAudioTrack#stopped\n */\nmodule.exports = LocalAudioTrack;\n//# sourceMappingURL=localaudiotrack.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\n\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\n\n\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var isProperty = false;\n\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {// its okay to eat failure here.\n  } // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n\n\n  if (isProperty) {\n    return;\n  }\n\n  var type;\n\n  try {\n    type = typeof source[methodName];\n  } catch (error) {// NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n\n\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\n\n\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\n\n\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\n\n\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' ? navigator.userAgent : null;\n}\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\n\n\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n\n  if (/Safari/.test(userAgent)) {\n    return 'safari';\n  }\n\n  return null;\n}\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\n\n\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\n\n\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n\n  return /Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent);\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\n\n\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function get() {\n      return currentListener;\n    },\n    set: function set(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\n\n\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function (result) {\n      onSuccess(result);\n    }, function (error) {\n      onFailure(error);\n    });\n  }\n\n  return promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\n\n\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\n\n\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function get() {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\n\n\nfunction support() {\n  return typeof navigator === 'object' && typeof navigator.mediaDevices === 'object' && typeof navigator.mediaDevices.getUserMedia === 'function' && typeof RTCPeerConnection === 'function';\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;","map":{"version":3,"sources":["/Users/javierjimenez/cuemeinDeploy/capstone/node_modules/@twilio/webrtc/lib/util/index.js"],"names":["defer","deferred","promise","Promise","resolve","reject","delegateMethod","source","wrapper","target","methodName","match","isProperty","propDesc","Object","getOwnPropertyDescriptor","get","error","type","apply","arguments","delegateMethods","difference","list1","list2","Array","isArray","Set","values","forEach","item","has","add","flatMap","list","mapFn","listArray","Map","from","reduce","flattened","mapped","concat","getUserAgent","navigator","userAgent","guessBrowser","test","guessBrowserVersion","prefix","chrome","firefox","safari","regex","RegExp","versions","split","map","Number","major","isNaN","minor","isIOSChrome","interceptEvent","currentListener","defineProperty","set","newListener","removeEventListener","addEventListener","legacyPromise","onSuccess","onFailure","then","result","makeUUID","replace","c","r","Math","random","v","toString","proxyProperties","getOwnPropertyNames","propertyName","proxyProperty","value","writable","slice","dispatchEvent","enumerable","support","mediaDevices","getUserMedia","RTCPeerConnection","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function(resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n\n  var isProperty = false;\n  try {\n    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);\n    isProperty = propDesc && !!propDesc.get;\n  } catch (error) {\n    // its okay to eat failure here.\n  }\n\n  // NOTE(mpatwardhan):skip properties. we are only interested in overriding\n  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties\n  // because getter would get invoked, and they might have side effects.\n  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.\n  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects\n  // we see errors.\n  if (isProperty) {\n    return;\n  }\n\n  var type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function() {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n\n  var difference = new Set();\n\n  list1.forEach(function(item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n\n  return difference;\n}\n\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set\n    ? Array.from(list.values())\n    : list;\n\n  return listArray.reduce(function(flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n\n/**\n * Get the browser's user agent, if available.\n * @returns {?string}\n */\nfunction getUserAgent() {\n  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'\n    ? navigator.userAgent\n    : null;\n}\n\n/**\n * Guess the browser.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  if (/Chrome|CriOS/.test(userAgent)) {\n    return 'chrome';\n  }\n  if (/Firefox|FxiOS/.test(userAgent)) {\n    return 'firefox';\n  }\n  if (/Safari/.test(userAgent)) {\n    return 'safari';\n  }\n  return null;\n}\n\n/**\n * Guess the browser version.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {?{major: number, minor: number}}\n */\nfunction guessBrowserVersion(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  var prefix = {\n    chrome: 'Chrome|CriOS',\n    firefox: 'Firefox|FxiOS',\n    safari: 'Version'\n  }[guessBrowser(userAgent)];\n\n  if (!prefix) {\n    return null;\n  }\n  var regex = new RegExp('(' + prefix + ')/([^\\\\s]+)');\n  var match = (userAgent.match(regex) || [])[2];\n\n  if (!match) {\n    return null;\n  }\n  var versions = match.split('.').map(Number);\n  return {\n    major: isNaN(versions[0]) ? null : versions[0],\n    minor: isNaN(versions[1]) ? null : versions[1]\n  };\n}\n\n/**\n * Check whether the current browser is iOS Chrome.\n * @param {string} [userAgent=navigator.userAgent]\n * @returns {boolean}\n */\nfunction isIOSChrome(userAgent) {\n  if (typeof userAgent === 'undefined') {\n    userAgent = getUserAgent();\n  }\n  return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));\n}\n\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function() {\n      return currentListener;\n    },\n    set: function(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function(result) {\n      onSuccess(result);\n    }, function(error) {\n      onFailure(error);\n    });\n  }\n  return promise;\n}\n\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function(propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n\n    target.addEventListener(propertyName.slice(2), function() {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function() {\n      return target[propertyName];\n    }\n  });\n}\n\n/**\n * Check whether native WebRTC APIs are supported.\n * @returns {boolean}\n */\nfunction support() {\n  return typeof navigator === 'object'\n    && typeof navigator.mediaDevices === 'object'\n    && typeof navigator.mediaDevices.getUserMedia === 'function'\n    && typeof RTCPeerConnection === 'function';\n}\n\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.guessBrowserVersion = guessBrowserVersion;\nexports.isIOSChrome = isIOSChrome;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\nexports.support = support;\n"]},"metadata":{},"sourceType":"script"}
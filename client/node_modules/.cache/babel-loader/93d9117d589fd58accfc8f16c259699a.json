{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _a = require('@twilio/webrtc/lib/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar detectSilentVideo = require('../../util/detectsilentvideo');\n\nvar mixinLocalMediaTrack = require('./localmediatrack');\n\nvar VideoTrack = require('./videotrack');\n\nvar isUserMediaTrack = require('../../util').isUserMediaTrack;\n\nvar LocalMediaVideoTrack = mixinLocalMediaTrack(VideoTrack);\n/**\n * A {@link LocalVideoTrack} is a {@link VideoTrack} representing video that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalVideoTrack#enable} and\n * {@link LocalVideoTrack#disable} or stopped completely with\n * {@link LocalVideoTrack#stop}.\n * @extends VideoTrack\n * @property {Track.ID} id - The {@link LocalVideoTrack}'s ID\n * @property {boolean} isStopped - Whether or not the {@link LocalVideoTrack} is\n *   stopped\n * @emits LocalVideoTrack#disabled\n * @emits LocalVideoTrack#enabled\n * @emits LocalVideoTrack#started\n * @emits LocalVideoTrack#stopped\n */\n\nvar LocalVideoTrack = function (_super) {\n  __extends(LocalVideoTrack, _super);\n  /**\n   * Construct a {@link LocalVideoTrack} from a MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n   * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n   */\n\n\n  function LocalVideoTrack(mediaStreamTrack, options) {\n    var _this = this;\n\n    options = Object.assign({\n      workaroundSilentLocalVideo: (guessBrowser() === 'safari' || isIOSChrome()) && isUserMediaTrack(mediaStreamTrack) && typeof document !== 'undefined' && typeof document.createElement === 'function'\n    }, options);\n    _this = _super.call(this, mediaStreamTrack, options) || this;\n    Object.defineProperties(_this, {\n      _workaroundSilentLocalVideo: {\n        value: options.workaroundSilentLocalVideo ? workaroundSilentLocalVideo : null\n      },\n      _workaroundSilentLocalVideoCleanup: {\n        value: null,\n        writable: true\n      }\n    }); // NOTE(mmalavalli): In iOS Safari, we work around a bug where local video\n    // MediaStreamTracks are silent (even though they are enabled, live and unmuted)\n    // after accepting/rejecting a phone call.\n\n    if (_this._workaroundSilentLocalVideo) {\n      _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);\n    }\n\n    return _this;\n  }\n\n  LocalVideoTrack.prototype.toString = function () {\n    return \"[LocalVideoTrack #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n  /**\n   * @private\n   */\n\n\n  LocalVideoTrack.prototype._checkIfCanCaptureFrames = function () {\n    return _super.prototype._checkIfCanCaptureFrames.call(this, this._trackSender.isPublishing);\n  };\n  /**\n   * @private\n   */\n\n\n  LocalVideoTrack.prototype._end = function () {\n    return _super.prototype._end.apply(this, arguments);\n  };\n  /**\n   * @private\n   */\n\n\n  LocalVideoTrack.prototype._setSenderMediaStreamTrack = function (useProcessed) {\n    var _this = this;\n\n    var unprocessedTrack = this.mediaStreamTrack;\n    var mediaStreamTrack = useProcessed ? this.processedTrack : unprocessedTrack;\n    return this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n      return _this._log.warn('setMediaStreamTrack failed on LocalVideoTrack RTCRtpSender', {\n        error: error,\n        mediaStreamTrack: mediaStreamTrack\n      });\n    }).then(function () {\n      _this._unprocessedTrack = useProcessed ? unprocessedTrack : null;\n    });\n  };\n  /**\n   * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n   * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   * localVideoTrack.addProcessor(new GrayScaleProcessor(100));\n   */\n\n\n  LocalVideoTrack.prototype.addProcessor = function () {\n    this._log.debug('Adding VideoProcessor to the LocalVideoTrack');\n\n    var result = _super.prototype.addProcessor.apply(this, arguments);\n\n    if (!this.processedTrack) {\n      return this._log.warn('Unable to add a VideoProcessor to the LocalVideoTrack');\n    }\n\n    this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n\n    this._setSenderMediaStreamTrack(true);\n\n    return result;\n  };\n  /**\n   * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n   * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n   * @returns {this}\n   * @example\n   * class GrayScaleProcessor {\n   *   constructor(percentage) {\n   *     this.percentage = percentage;\n   *   }\n   *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n   *     const context = outputFrameBuffer.getContext('2d');\n   *     context.filter = `grayscale(${this.percentage}%)`;\n   *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n   *   }\n   * }\n   *\n   * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   * const grayScaleProcessor = new GrayScaleProcessor(100);\n   * localVideoTrack.addProcessor(grayScaleProcessor);\n   *\n   * document.getElementById('remove-button').onclick = () => localVideoTrack.removeProcessor(grayScaleProcessor);\n   */\n\n\n  LocalVideoTrack.prototype.removeProcessor = function () {\n    var _this = this;\n\n    this._log.debug('Removing VideoProcessor from the LocalVideoTrack');\n\n    var result = _super.prototype.removeProcessor.apply(this, arguments);\n\n    this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the original MediaStreamTrack');\n\n    this._setSenderMediaStreamTrack().then(function () {\n      return _this._updateElementsMediaStreamTrack();\n    });\n\n    return result;\n  };\n  /**\n   * Disable the {@link LocalVideoTrack}. This is effectively \"pause\".\n   * If a {@link VideoProcessor} is added, then `processedTrack` is disabled as well.\n   * @returns {this}\n   * @fires VideoTrack#disabled\n   */\n\n\n  LocalVideoTrack.prototype.disable = function () {\n    var result = _super.prototype.disable.apply(this, arguments);\n\n    if (this.processedTrack) {\n      this.processedTrack.enabled = false;\n    }\n\n    return result;\n  };\n  /**\n   * Enable the {@link LocalVideoTrack}. This is effectively \"unpause\".\n   * If a {@link VideoProcessor} is added, then `processedTrack` is enabled as well.\n   * @returns {this}\n   * @fires VideoTrack#enabled\n  */\n\n  /**\n  * Enable or disable the {@link LocalVideoTrack}. This is effectively \"unpause\"\n  * or \"pause\". If a {@link VideoProcessor} is added,\n  * then `processedTrack` is enabled or disabled as well.\n  * @param {boolean} [enabled] - Specify false to pause the\n  *   {@link LocalVideoTrack}\n  * @returns {this}\n  * @fires VideoTrack#disabled\n  * @fires VideoTrack#enabled\n  */\n\n\n  LocalVideoTrack.prototype.enable = function (enabled) {\n    if (enabled === void 0) {\n      enabled = true;\n    }\n\n    var result = _super.prototype.enable.apply(this, arguments);\n\n    if (this.processedTrack) {\n      this.processedTrack.enabled = enabled;\n\n      if (enabled) {\n        this._captureFrames();\n\n        this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n\n        this._setSenderMediaStreamTrack(true);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Restart the {@link LocalVideoTrack}. This stops the existing MediaStreamTrack\n   * and creates a new MediaStreamTrack. If the {@link LocalVideoTrack} is being published\n   * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n   * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n   * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n   * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n   * the {@link LocalVideoTrack}'s ID is no longer guaranteed to be the same as the\n   * underlying MediaStreamTrack's ID.\n   * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n   *   for restarting the {@link LocalVideoTrack}; If not specified, then the current MediaTrackConstraints\n   *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n   *   will be used\n   * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalVideoTrack} was not created\n   *   using an one of <code>createLocalVideoTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n   *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n   *   raised by <code>getUserMedia</code> when it fails\n   * @fires LocalVideoTrack#stopped\n   * @fires LocalVideoTrack#started\n   * @example\n   * const { connect, createLocalVideoTrack } = require('twilio-video');\n   *\n   * // Create a LocalVideoTrack that captures video from the front-facing camera.\n   * createLocalVideoTrack({ facingMode: 'user' }).then(function(localVideoTrack) {\n   *   return connect('token', {\n   *     name: 'my-cool-room',\n   *     tracks: [localVideoTrack]\n   *   });\n   * }).then(function(room) {\n   *   // Restart the LocalVideoTrack to capture video from the back-facing camera.\n   *   const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n   *   return localVideoTrack.restart({ facingMode: 'environment' });\n   * });\n   */\n\n\n  LocalVideoTrack.prototype.restart = function () {\n    var _this = this;\n\n    if (this._workaroundSilentLocalVideoCleanup) {\n      this._workaroundSilentLocalVideoCleanup();\n\n      this._workaroundSilentLocalVideoCleanup = null;\n    }\n\n    var promise = _super.prototype.restart.apply(this, arguments);\n\n    if (this.processor) {\n      promise.then(function () {\n        _this._restartProcessor();\n      });\n    }\n\n    if (this._workaroundSilentLocalVideo) {\n      promise.finally(function () {\n        _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);\n      });\n    }\n\n    return promise;\n  };\n  /**\n   * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n   * {@link LocalVideoTrack}, you should unpublish it after stopping.\n   * @returns {this}\n   * @fires LocalVideoTrack#stopped\n   */\n\n\n  LocalVideoTrack.prototype.stop = function () {\n    if (this._workaroundSilentLocalVideoCleanup) {\n      this._workaroundSilentLocalVideoCleanup();\n\n      this._workaroundSilentLocalVideoCleanup = null;\n    }\n\n    return _super.prototype.stop.apply(this, arguments);\n  };\n\n  return LocalVideoTrack;\n}(LocalMediaVideoTrack);\n/**\n * Work around a bug where local video MediaStreamTracks are silent (even though\n * they are enabled, live and unmuted) after accepting/rejecting a phone call.\n * @private\n * @param {LocalVideoTrack} localVideoTrack\n * @param {HTMLDocument} doc\n * @returns {function} Cleans up listeners attached by the workaround\n */\n\n\nfunction workaroundSilentLocalVideo(localVideoTrack, doc) {\n  var log = localVideoTrack._log;\n  var el = localVideoTrack._dummyEl,\n      mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n\n  function onUnmute() {\n    if (!localVideoTrack.isEnabled) {\n      return;\n    }\n\n    log.info('Unmuted, checking silence'); // The dummy element is paused, so play it and then detect silence.\n\n    el.play().then(function () {\n      return detectSilentVideo(el, doc);\n    }).then(function (isSilent) {\n      if (!isSilent) {\n        log.info('Non-silent frames detected, so no need to restart');\n        return;\n      }\n\n      log.warn('Silence detected, restarting'); // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised. Hence,\n      // we stop the MediaStreamTrack here.\n\n      localVideoTrack._stop(); // Restart the LocalVideoTrack.\n      // eslint-disable-next-line consistent-return\n\n\n      return localVideoTrack._restart();\n    }).catch(function (error) {\n      log.warn('Failed to detect silence and restart:', error);\n    }).finally(function () {\n      // If silent frames were not detected, then pause the dummy element again.\n      el = localVideoTrack._dummyEl;\n\n      if (!el.paused) {\n        el.pause();\n      } // Reset the unmute handler.\n\n\n      mediaStreamTrack.removeEventListener('unmute', onUnmute);\n      mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n      mediaStreamTrack.addEventListener('unmute', onUnmute);\n    });\n  } // Set the unmute handler.\n\n\n  mediaStreamTrack.addEventListener('unmute', onUnmute);\n  return function () {\n    mediaStreamTrack.removeEventListener('unmute', onUnmute);\n  };\n}\n/**\n * The {@link LocalVideoTrack} was disabled, i.e. \"muted\".\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was\n *   disabled\n * @event LocalVideoTrack#disabled\n */\n\n/**\n * The {@link LocalVideoTrack} was enabled, i.e. \"unmuted\".\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was enabled\n * @event LocalVideoTrack#enabled\n */\n\n/**\n * The {@link LocalVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that started\n * @event LocalVideoTrack#started\n */\n\n/**\n * The {@link LocalVideoTrack} stopped, either because {@link LocalVideoTrack#stop}\n * or {@link LocalVideoTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that stopped\n * @event LocalVideoTrack#stopped\n */\n\n\nmodule.exports = LocalVideoTrack;","map":{"version":3,"sources":["../../../lib/media/track/localvideotrack.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a = require('@twilio/webrtc/lib/util'), guessBrowser = _a.guessBrowser, isIOSChrome = _a.isIOSChrome;\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar mixinLocalMediaTrack = require('./localmediatrack');\nvar VideoTrack = require('./videotrack');\nvar isUserMediaTrack = require('../../util').isUserMediaTrack;\nvar LocalMediaVideoTrack = mixinLocalMediaTrack(VideoTrack);\n/**\n * A {@link LocalVideoTrack} is a {@link VideoTrack} representing video that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalVideoTrack#enable} and\n * {@link LocalVideoTrack#disable} or stopped completely with\n * {@link LocalVideoTrack#stop}.\n * @extends VideoTrack\n * @property {Track.ID} id - The {@link LocalVideoTrack}'s ID\n * @property {boolean} isStopped - Whether or not the {@link LocalVideoTrack} is\n *   stopped\n * @emits LocalVideoTrack#disabled\n * @emits LocalVideoTrack#enabled\n * @emits LocalVideoTrack#started\n * @emits LocalVideoTrack#stopped\n */\nvar LocalVideoTrack = /** @class */ (function (_super) {\n    __extends(LocalVideoTrack, _super);\n    /**\n     * Construct a {@link LocalVideoTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    function LocalVideoTrack(mediaStreamTrack, options) {\n        var _this = this;\n        options = Object.assign({\n            workaroundSilentLocalVideo: (guessBrowser() === 'safari' || isIOSChrome())\n                && isUserMediaTrack(mediaStreamTrack)\n                && typeof document !== 'undefined'\n                && typeof document.createElement === 'function'\n        }, options);\n        _this = _super.call(this, mediaStreamTrack, options) || this;\n        Object.defineProperties(_this, {\n            _workaroundSilentLocalVideo: {\n                value: options.workaroundSilentLocalVideo\n                    ? workaroundSilentLocalVideo\n                    : null\n            },\n            _workaroundSilentLocalVideoCleanup: {\n                value: null,\n                writable: true\n            }\n        });\n        // NOTE(mmalavalli): In iOS Safari, we work around a bug where local video\n        // MediaStreamTracks are silent (even though they are enabled, live and unmuted)\n        // after accepting/rejecting a phone call.\n        if (_this._workaroundSilentLocalVideo) {\n            _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);\n        }\n        return _this;\n    }\n    LocalVideoTrack.prototype.toString = function () {\n        return \"[LocalVideoTrack #\" + this._instanceId + \": \" + this.id + \"]\";\n    };\n    /**\n     * @private\n     */\n    LocalVideoTrack.prototype._checkIfCanCaptureFrames = function () {\n        return _super.prototype._checkIfCanCaptureFrames.call(this, this._trackSender.isPublishing);\n    };\n    /**\n     * @private\n     */\n    LocalVideoTrack.prototype._end = function () {\n        return _super.prototype._end.apply(this, arguments);\n    };\n    /**\n     * @private\n     */\n    LocalVideoTrack.prototype._setSenderMediaStreamTrack = function (useProcessed) {\n        var _this = this;\n        var unprocessedTrack = this.mediaStreamTrack;\n        var mediaStreamTrack = useProcessed ? this.processedTrack : unprocessedTrack;\n        return this._trackSender.setMediaStreamTrack(mediaStreamTrack)\n            .catch(function (error) { return _this._log.warn('setMediaStreamTrack failed on LocalVideoTrack RTCRtpSender', { error: error, mediaStreamTrack: mediaStreamTrack }); })\n            .then(function () {\n            _this._unprocessedTrack = useProcessed ? unprocessedTrack : null;\n        });\n    };\n    /**\n     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.\n     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.\n     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.\n     * @returns {this}\n     * @example\n     * class GrayScaleProcessor {\n     *   constructor(percentage) {\n     *     this.percentage = percentage;\n     *   }\n     *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n     *     const context = outputFrameBuffer.getContext('2d');\n     *     context.filter = `grayscale(${this.percentage}%)`;\n     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n     *   }\n     * }\n     *\n     * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n     * localVideoTrack.addProcessor(new GrayScaleProcessor(100));\n     */\n    LocalVideoTrack.prototype.addProcessor = function () {\n        this._log.debug('Adding VideoProcessor to the LocalVideoTrack');\n        var result = _super.prototype.addProcessor.apply(this, arguments);\n        if (!this.processedTrack) {\n            return this._log.warn('Unable to add a VideoProcessor to the LocalVideoTrack');\n        }\n        this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n        this._setSenderMediaStreamTrack(true);\n        return result;\n    };\n    /**\n     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.\n     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.\n     * @returns {this}\n     * @example\n     * class GrayScaleProcessor {\n     *   constructor(percentage) {\n     *     this.percentage = percentage;\n     *   }\n     *   processFrame(inputFrameBuffer, outputFrameBuffer) {\n     *     const context = outputFrameBuffer.getContext('2d');\n     *     context.filter = `grayscale(${this.percentage}%)`;\n     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);\n     *   }\n     * }\n     *\n     * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n     * const grayScaleProcessor = new GrayScaleProcessor(100);\n     * localVideoTrack.addProcessor(grayScaleProcessor);\n     *\n     * document.getElementById('remove-button').onclick = () => localVideoTrack.removeProcessor(grayScaleProcessor);\n     */\n    LocalVideoTrack.prototype.removeProcessor = function () {\n        var _this = this;\n        this._log.debug('Removing VideoProcessor from the LocalVideoTrack');\n        var result = _super.prototype.removeProcessor.apply(this, arguments);\n        this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the original MediaStreamTrack');\n        this._setSenderMediaStreamTrack()\n            .then(function () { return _this._updateElementsMediaStreamTrack(); });\n        return result;\n    };\n    /**\n     * Disable the {@link LocalVideoTrack}. This is effectively \"pause\".\n     * If a {@link VideoProcessor} is added, then `processedTrack` is disabled as well.\n     * @returns {this}\n     * @fires VideoTrack#disabled\n     */\n    LocalVideoTrack.prototype.disable = function () {\n        var result = _super.prototype.disable.apply(this, arguments);\n        if (this.processedTrack) {\n            this.processedTrack.enabled = false;\n        }\n        return result;\n    };\n    /**\n     * Enable the {@link LocalVideoTrack}. This is effectively \"unpause\".\n     * If a {@link VideoProcessor} is added, then `processedTrack` is enabled as well.\n     * @returns {this}\n     * @fires VideoTrack#enabled\n    */ /**\n     * Enable or disable the {@link LocalVideoTrack}. This is effectively \"unpause\"\n     * or \"pause\". If a {@link VideoProcessor} is added,\n     * then `processedTrack` is enabled or disabled as well.\n     * @param {boolean} [enabled] - Specify false to pause the\n     *   {@link LocalVideoTrack}\n     * @returns {this}\n     * @fires VideoTrack#disabled\n     * @fires VideoTrack#enabled\n     */\n    LocalVideoTrack.prototype.enable = function (enabled) {\n        if (enabled === void 0) { enabled = true; }\n        var result = _super.prototype.enable.apply(this, arguments);\n        if (this.processedTrack) {\n            this.processedTrack.enabled = enabled;\n            if (enabled) {\n                this._captureFrames();\n                this._log.debug('Updating LocalVideoTrack\\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);\n                this._setSenderMediaStreamTrack(true);\n            }\n        }\n        return result;\n    };\n    /**\n     * Restart the {@link LocalVideoTrack}. This stops the existing MediaStreamTrack\n     * and creates a new MediaStreamTrack. If the {@link LocalVideoTrack} is being published\n     * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n     * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n     * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n     * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n     * the {@link LocalVideoTrack}'s ID is no longer guaranteed to be the same as the\n     * underlying MediaStreamTrack's ID.\n     * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n     *   for restarting the {@link LocalVideoTrack}; If not specified, then the current MediaTrackConstraints\n     *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n     *   will be used\n     * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalVideoTrack} was not created\n     *   using an one of <code>createLocalVideoTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n     *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n     *   raised by <code>getUserMedia</code> when it fails\n     * @fires LocalVideoTrack#stopped\n     * @fires LocalVideoTrack#started\n     * @example\n     * const { connect, createLocalVideoTrack } = require('twilio-video');\n     *\n     * // Create a LocalVideoTrack that captures video from the front-facing camera.\n     * createLocalVideoTrack({ facingMode: 'user' }).then(function(localVideoTrack) {\n     *   return connect('token', {\n     *     name: 'my-cool-room',\n     *     tracks: [localVideoTrack]\n     *   });\n     * }).then(function(room) {\n     *   // Restart the LocalVideoTrack to capture video from the back-facing camera.\n     *   const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;\n     *   return localVideoTrack.restart({ facingMode: 'environment' });\n     * });\n     */\n    LocalVideoTrack.prototype.restart = function () {\n        var _this = this;\n        if (this._workaroundSilentLocalVideoCleanup) {\n            this._workaroundSilentLocalVideoCleanup();\n            this._workaroundSilentLocalVideoCleanup = null;\n        }\n        var promise = _super.prototype.restart.apply(this, arguments);\n        if (this.processor) {\n            promise.then(function () {\n                _this._restartProcessor();\n            });\n        }\n        if (this._workaroundSilentLocalVideo) {\n            promise.finally(function () {\n                _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);\n            });\n        }\n        return promise;\n    };\n    /**\n     * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n     * {@link LocalVideoTrack}, you should unpublish it after stopping.\n     * @returns {this}\n     * @fires LocalVideoTrack#stopped\n     */\n    LocalVideoTrack.prototype.stop = function () {\n        if (this._workaroundSilentLocalVideoCleanup) {\n            this._workaroundSilentLocalVideoCleanup();\n            this._workaroundSilentLocalVideoCleanup = null;\n        }\n        return _super.prototype.stop.apply(this, arguments);\n    };\n    return LocalVideoTrack;\n}(LocalMediaVideoTrack));\n/**\n * Work around a bug where local video MediaStreamTracks are silent (even though\n * they are enabled, live and unmuted) after accepting/rejecting a phone call.\n * @private\n * @param {LocalVideoTrack} localVideoTrack\n * @param {HTMLDocument} doc\n * @returns {function} Cleans up listeners attached by the workaround\n */\nfunction workaroundSilentLocalVideo(localVideoTrack, doc) {\n    var log = localVideoTrack._log;\n    var el = localVideoTrack._dummyEl, mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n    function onUnmute() {\n        if (!localVideoTrack.isEnabled) {\n            return;\n        }\n        log.info('Unmuted, checking silence');\n        // The dummy element is paused, so play it and then detect silence.\n        el.play().then(function () { return detectSilentVideo(el, doc); }).then(function (isSilent) {\n            if (!isSilent) {\n                log.info('Non-silent frames detected, so no need to restart');\n                return;\n            }\n            log.warn('Silence detected, restarting');\n            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n            // without stopping it first, then a NotReadableError is raised. Hence,\n            // we stop the MediaStreamTrack here.\n            localVideoTrack._stop();\n            // Restart the LocalVideoTrack.\n            // eslint-disable-next-line consistent-return\n            return localVideoTrack._restart();\n        }).catch(function (error) {\n            log.warn('Failed to detect silence and restart:', error);\n        }).finally(function () {\n            // If silent frames were not detected, then pause the dummy element again.\n            el = localVideoTrack._dummyEl;\n            if (!el.paused) {\n                el.pause();\n            }\n            // Reset the unmute handler.\n            mediaStreamTrack.removeEventListener('unmute', onUnmute);\n            mediaStreamTrack = localVideoTrack.mediaStreamTrack;\n            mediaStreamTrack.addEventListener('unmute', onUnmute);\n        });\n    }\n    // Set the unmute handler.\n    mediaStreamTrack.addEventListener('unmute', onUnmute);\n    return function () {\n        mediaStreamTrack.removeEventListener('unmute', onUnmute);\n    };\n}\n/**\n * The {@link LocalVideoTrack} was disabled, i.e. \"muted\".\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was\n *   disabled\n * @event LocalVideoTrack#disabled\n */\n/**\n * The {@link LocalVideoTrack} was enabled, i.e. \"unmuted\".\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was enabled\n * @event LocalVideoTrack#enabled\n */\n/**\n * The {@link LocalVideoTrack} started. This means there is enough video data\n * to begin playback.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that started\n * @event LocalVideoTrack#started\n */\n/**\n * The {@link LocalVideoTrack} stopped, either because {@link LocalVideoTrack#stop}\n * or {@link LocalVideoTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that stopped\n * @event LocalVideoTrack#stopped\n */\nmodule.exports = LocalVideoTrack;\n//# sourceMappingURL=localvideotrack.js.map"]},"metadata":{},"sourceType":"script"}
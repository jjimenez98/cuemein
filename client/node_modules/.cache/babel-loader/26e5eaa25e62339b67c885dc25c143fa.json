{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mosToScore = exports.calculateMOS = void 0;\nvar r0 = 94.768; // Constant used in computing \"rFactor\".\n// copied from https://code.hq.twilio.com/client/sdk-frd/blob/master/voice/voice-mos-calculation.md\n\nfunction calculateMOS(rtt, jitter, fractionLost) {\n  // Compute the effective latency.\n  var effectiveLatency = rtt + jitter * 2 + 10; // Compute the initial \"rFactor\" from effective latency.\n\n  var rFactor = 0;\n\n  switch (true) {\n    case effectiveLatency < 160:\n      rFactor = r0 - effectiveLatency / 40;\n      break;\n\n    case effectiveLatency < 1000:\n      rFactor = r0 - (effectiveLatency - 120) / 10;\n      break;\n  } // Adjust \"rFactor\" with the fraction of packets lost.\n\n\n  switch (true) {\n    case fractionLost <= rFactor / 2.5:\n      rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);\n      break;\n\n    default:\n      rFactor = 0;\n      break;\n  } // Compute MOS from \"rFactor\".\n\n\n  var mos = 1 + 0.035 * rFactor + 0.000007 * rFactor * (rFactor - 60) * (100 - rFactor);\n  return mos;\n}\n\nexports.calculateMOS = calculateMOS;\n\nfunction mosToScore(mosValue) {\n  var score = 0;\n\n  if (!mosValue) {\n    score = 0;\n  } else if (mosValue > 4.2) {\n    score = 5;\n  } else if (mosValue > 4.0) {\n    score = 4;\n  } else if (mosValue > 3.6) {\n    score = 3;\n  } else if (mosValue > 3) {\n    score = 2;\n  } else {\n    score = 1;\n  }\n\n  return score;\n}\n\nexports.mosToScore = mosToScore;","map":{"version":3,"sources":["../../lib/preflight/mos.ts"],"names":[],"mappings":";;;;;;AAAA,IAAM,EAAE,GAAG,MAAX,C,CAAmB;AACnB;;AACA,SAAgB,YAAhB,CAA6B,GAA7B,EAA0C,MAA1C,EAA0D,YAA1D,EAA8E;AAC5E;AACA,MAAM,gBAAgB,GAAW,GAAG,GAAI,MAAM,GAAG,CAAhB,GAAqB,EAAtD,CAF4E,CAI5E;;AACA,MAAI,OAAO,GAAG,CAAd;;AACA,UAAQ,IAAR;AACE,SAAK,gBAAgB,GAAG,GAAxB;AACE,MAAA,OAAO,GAAG,EAAE,GAAI,gBAAgB,GAAG,EAAnC;AACA;;AACF,SAAK,gBAAgB,GAAG,IAAxB;AACE,MAAA,OAAO,GAAG,EAAE,GAAI,CAAC,gBAAgB,GAAG,GAApB,IAA2B,EAA3C;AACA;AANJ,GAN4E,CAe5E;;;AACA,UAAQ,IAAR;AACE,SAAK,YAAY,IAAK,OAAO,GAAG,GAAhC;AACE,MAAA,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,OAAO,GAAG,YAAY,GAAG,GAAlC,EAAuC,IAAvC,CAAV;AACA;;AACF;AACE,MAAA,OAAO,GAAG,CAAV;AACA;AANJ,GAhB4E,CAyB5E;;;AACA,MAAM,GAAG,GAAW,IACjB,QAAQ,OADS,GAEjB,WAAW,OAAZ,IACC,OAAO,GAAG,EADX,KAEC,MAAM,OAFP,CAFF;AAMA,SAAO,GAAP;AACD;;AAjCD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAmCA,SAAgB,UAAhB,CAA2B,QAA3B,EAA0D;AACxD,MAAI,KAAK,GAAG,CAAZ;;AACA,MAAI,CAAC,QAAL,EAAe;AACb,IAAA,KAAK,GAAG,CAAR;AACD,GAFD,MAEO,IAAK,QAAQ,GAAG,GAAhB,EAAqB;AAC1B,IAAA,KAAK,GAAG,CAAR;AACD,GAFM,MAEA,IAAK,QAAQ,GAAG,GAAhB,EAAqB;AAC1B,IAAA,KAAK,GAAG,CAAR;AACD,GAFM,MAEA,IAAK,QAAQ,GAAG,GAAhB,EAAqB;AAC1B,IAAA,KAAK,GAAG,CAAR;AACD,GAFM,MAEA,IAAK,QAAQ,GAAG,CAAhB,EAAmB;AACxB,IAAA,KAAK,GAAG,CAAR;AACD,GAFM,MAEC;AACN,IAAA,KAAK,GAAG,CAAR;AACD;;AACD,SAAO,KAAP;AACD;;AAhBD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mosToScore = exports.calculateMOS = void 0;\nvar r0 = 94.768; // Constant used in computing \"rFactor\".\n// copied from https://code.hq.twilio.com/client/sdk-frd/blob/master/voice/voice-mos-calculation.md\nfunction calculateMOS(rtt, jitter, fractionLost) {\n    // Compute the effective latency.\n    var effectiveLatency = rtt + (jitter * 2) + 10;\n    // Compute the initial \"rFactor\" from effective latency.\n    var rFactor = 0;\n    switch (true) {\n        case effectiveLatency < 160:\n            rFactor = r0 - (effectiveLatency / 40);\n            break;\n        case effectiveLatency < 1000:\n            rFactor = r0 - ((effectiveLatency - 120) / 10);\n            break;\n    }\n    // Adjust \"rFactor\" with the fraction of packets lost.\n    switch (true) {\n        case fractionLost <= (rFactor / 2.5):\n            rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);\n            break;\n        default:\n            rFactor = 0;\n            break;\n    }\n    // Compute MOS from \"rFactor\".\n    var mos = 1 +\n        (0.035 * rFactor) +\n        (0.000007 * rFactor) *\n            (rFactor - 60) *\n            (100 - rFactor);\n    return mos;\n}\nexports.calculateMOS = calculateMOS;\nfunction mosToScore(mosValue) {\n    var score = 0;\n    if (!mosValue) {\n        score = 0;\n    }\n    else if (mosValue > 4.2) {\n        score = 5;\n    }\n    else if (mosValue > 4.0) {\n        score = 4;\n    }\n    else if (mosValue > 3.6) {\n        score = 3;\n    }\n    else if (mosValue > 3) {\n        score = 2;\n    }\n    else {\n        score = 1;\n    }\n    return score;\n}\nexports.mosToScore = mosToScore;\n//# sourceMappingURL=mos.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _a = require('@twilio/webrtc/lib/util'),\n    guessBrowser = _a.guessBrowser,\n    isIOSChrome = _a.isIOSChrome;\n\nvar MediaStream = require('@twilio/webrtc').MediaStream;\n\nvar _b = require('../../util'),\n    waitForEvent = _b.waitForEvent,\n    waitForSometime = _b.waitForSometime;\n\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\n\nvar Track = require('./');\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\n\n\nvar MediaTrack = function (_super) {\n  __extends(MediaTrack, _super);\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n\n\n  function MediaTrack(mediaTrackTransceiver, options) {\n    var _this = this;\n\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: (guessBrowser() === 'safari' || isIOSChrome()) && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string'\n    }, options);\n    _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;\n    var isStarted = false;\n    options = Object.assign({\n      MediaStream: MediaStream\n    }, options);\n    /* istanbul ignore next */\n\n    Object.defineProperties(_this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get: function get() {\n          return isStarted;\n        },\n        set: function set(_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780 || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      isStarted: {\n        enumerable: true,\n        get: function get() {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get: function get() {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    _this._initialize();\n\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._start = function () {\n    this._log.debug('Started');\n\n    this._isStarted = true;\n\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    } // eslint-disable-next-line no-use-before-define\n\n\n    this.emit('started', this);\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._initialize = function () {\n    var self = this;\n\n    this._log.debug('Initializing');\n\n    this._dummyEl = this._createElement();\n    this.mediaStreamTrack.addEventListener('ended', function onended() {\n      self._end();\n\n      self.mediaStreamTrack.removeEventListener('ended', onended);\n    });\n\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl); // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n\n      this._attachments.delete(this._dummyEl);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._end = function () {\n    this._log.debug('Ended');\n\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n\n      this._dummyEl.srcObject = null;\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  };\n\n  MediaTrack.prototype.attach = function (el) {\n    var _this = this;\n\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n\n    this._log.debug('Attempting to attach to element:', el);\n\n    el = this._attach(el);\n\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded ? function () {\n        return playIfPausedAndNotBackgrounded(el, _this._log);\n      } : null;\n\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n\n    return el;\n  };\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n\n\n  MediaTrack.prototype._attach = function (el, mediaStreamTrack) {\n    if (mediaStreamTrack === void 0) {\n      mediaStreamTrack = this.processedTrack || this.mediaStreamTrack;\n    }\n\n    var mediaStream = el.srcObject;\n\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n\n    var getTracks = mediaStreamTrack.kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';\n    mediaStream[getTracks]().forEach(function (track) {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack); // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    //\n\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._selectElement = function (selector) {\n    var el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error(\"Selector matched no element: \" + selector);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._updateElementsMediaStreamTrack = function () {\n    var _this = this;\n\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n\n    this._getAllAttachedElements().forEach(function (el) {\n      return _this._attach(el);\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._createElement = function () {\n    return typeof document !== 'undefined' ? document.createElement(this.kind) : null;\n  };\n\n  MediaTrack.prototype.detach = function (el) {\n    var els;\n\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n\n    this._log.debug('Attempting to detach from elements:', els);\n\n    this._detachElements(els);\n\n    return el ? els[0] : els;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._detachElements = function (elements) {\n    return elements.map(this._detachElement.bind(this));\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._detachElement = function (el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n\n    var mediaStream = el.srcObject;\n\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n\n    this._attachments.delete(el);\n\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      var shim = this._elShims.get(el);\n\n      shim.unShim();\n\n      this._elShims.delete(el);\n    }\n\n    return el;\n  };\n  /**\n   * @private\n   */\n\n\n  MediaTrack.prototype._getAllAttachedElements = function () {\n    var els = [];\n\n    this._attachments.forEach(function (el) {\n      els.push(el);\n    });\n\n    return els;\n  };\n\n  return MediaTrack;\n}(Track);\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\n\n\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  var tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el); // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n\n  Promise.race([waitForEvent(document, 'visibilitychange'), waitForSometime(1000)]).then(function () {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(function () {\n        log.info(\"Playing unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n        return el.play();\n      }).then(function () {\n        log.info(\"Successfully played unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n      }).catch(function (error) {\n        log.warn(\"Error while playing unintentionally paused <\" + tag + \"> element:\", {\n          error: error,\n          el: el\n        });\n      });\n    }\n  });\n}\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\n\n\nfunction shimMediaElement(el, onUnintentionallyPaused) {\n  if (onUnintentionallyPaused === void 0) {\n    onUnintentionallyPaused = null;\n  }\n\n  var origPause = el.pause;\n  var origPlay = el.play;\n  var _pausedIntentionally = false;\n\n  el.pause = function () {\n    _pausedIntentionally = true;\n    return origPause.call(el);\n  };\n\n  el.play = function () {\n    _pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n\n  var onPause = onUnintentionallyPaused ? function () {\n    if (!_pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n\n  return {\n    pausedIntentionally: function pausedIntentionally() {\n      return _pausedIntentionally;\n    },\n    unShim: function unShim() {\n      el.pause = origPause;\n      el.play = origPlay;\n\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\n\nmodule.exports = MediaTrack;","map":{"version":3,"sources":["../../../lib/media/track/mediatrack.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEM,IAAA,EAAA,GAAgC,OAAO,CAAC,yBAAD,CAAvC;AAAA,IAAE,YAAY,GAAA,EAAA,CAAA,YAAd;AAAA,IAAgB,WAAW,GAAA,EAAA,CAAA,WAA3B;;AACE,IAAA,WAAW,GAAK,OAAO,CAAC,gBAAD,CAAP,CAAL,WAAX;;AAEF,IAAA,EAAA,GAAoC,OAAO,CAAC,YAAD,CAA3C;AAAA,IAAE,YAAY,GAAA,EAAA,CAAA,YAAd;AAAA,IAAgB,eAAe,GAAA,EAAA,CAAA,eAA/B;;AACN,IAAM,0BAA0B,GAAG,OAAO,CAAC,uCAAD,CAA1C;;AACA,IAAM,KAAK,GAAG,OAAO,CAAC,IAAD,CAArB;AAEA;;;;;;;;;;;;;;;;AAgBG;;;AACH,IAAA,UAAA,GAAA,UAAA,MAAA,EAAA;AAAyB,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;AACvB;;;;AAIG;;;AACH,WAAA,UAAA,CAAY,qBAAZ,EAAmC,OAAnC,EAA0C;AAA1C,QAAA,KAAA,GAAA,IAAA;;AACE,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc;AACtB,MAAA,mCAAmC,EAAE,CAAC,YAAY,OAAO,QAAnB,IAA+B,WAAW,EAA3C,KAChC,OAAO,QAAP,KAAoB,QADY,IAEhC,OAAO,QAAQ,CAAC,gBAAhB,KAAqC,UAFL,IAGhC,OAAO,QAAQ,CAAC,eAAhB,KAAoC;AAJnB,KAAd,EAKP,OALO,CAAV;AAOA,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,qBAAqB,CAAC,EAA5B,EAAgC,qBAAqB,CAAC,IAAtD,EAA4D,OAA5D,KAAoE,IAApE;AACA,QAAI,SAAS,GAAG,KAAhB;AAEA,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc;AACtB,MAAA,WAAW,EAAA;AADW,KAAd,EAEP,OAFO,CAAV;AAIA;;AACA,IAAA,MAAM,CAAC,gBAAP,CAAwB,KAAxB,EAA8B;AAC5B,MAAA,YAAY,EAAE;AACZ,QAAA,KAAK,EAAE,IAAI,GAAJ;AADK,OADc;AAI5B,MAAA,QAAQ,EAAE;AACR,QAAA,KAAK,EAAE,IADC;AAER,QAAA,QAAQ,EAAE;AAFF,OAJkB;AAQ5B,MAAA,QAAQ,EAAE;AACR,QAAA,KAAK,EAAE,IAAI,OAAJ;AADC,OARkB;AAW5B,MAAA,UAAU,EAAE;AACV,QAAA,GAAG,EAAA,eAAA;AACD,iBAAO,SAAP;AACD,SAHS;AAIV,QAAA,GAAG,EAAA,aAAC,UAAD,EAAW;AACZ,UAAA,SAAS,GAAG,UAAZ;AACD;AANS,OAXgB;AAmB5B,MAAA,oCAAoC,EAAE;AACpC,QAAA,KAAK,EAAE,OAAO,CAAC;AADqB,OAnBV;AAsB5B,MAAA,2BAA2B,EAAE;AAC3B,QAAA,KAAK,EAAE,OAAO,CAAC,yBAAR,IACF,OAAO,CAAC;AAFc,OAtBD;AA0B5B,MAAA,iBAAiB,EAAE;AACjB,QAAA,KAAK,EAAE,IADU;AAEjB,QAAA,QAAQ,EAAE;AAFO,OA1BS;AA8B5B,MAAA,YAAY,EAAE;AACZ,QAAA,KAAK,EAAE,OAAO,CAAC;AADH,OA9Bc;AAiC5B,MAAA,SAAS,EAAE;AACT,QAAA,UAAU,EAAE,IADH;AAET,QAAA,GAAG,EAAA,eAAA;AACD,iBAAO,SAAP;AACD;AAJQ,OAjCiB;AAuC5B,MAAA,gBAAgB,EAAE;AAChB,QAAA,UAAU,EAAE,IADI;AAEhB,QAAA,GAAG,EAAA,eAAA;AACD,iBAAO,KAAK,iBAAL,IAA0B,qBAAqB,CAAC,KAAvD;AACD;AAJe,OAvCU;AA6C5B,MAAA,cAAc,EAAE;AACd,QAAA,UAAU,EAAE,IADE;AAEd,QAAA,KAAK,EAAE,IAFO;AAGd,QAAA,QAAQ,EAAE;AAHI;AA7CY,KAA9B;;AAoDA,IAAA,KAAI,CAAC,WAAL;;;AACD;AAED;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACE,SAAK,IAAL,CAAU,KAAV,CAAgB,SAAhB;;AACA,SAAK,UAAL,GAAkB,IAAlB;;AACA,QAAI,KAAK,QAAT,EAAmB;AACjB,WAAK,QAAL,CAAc,SAAd,GAA0B,IAA1B;AACD,KALH,CAME;;;AACA,SAAK,IAAL,CAAU,SAAV,EAAqB,IAArB;AACD,GARD;AAUA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,QAAM,IAAI,GAAG,IAAb;;AAEA,SAAK,IAAL,CAAU,KAAV,CAAgB,cAAhB;;AACA,SAAK,QAAL,GAAgB,KAAK,cAAL,EAAhB;AAEA,SAAK,gBAAL,CAAsB,gBAAtB,CAAuC,OAAvC,EAAgD,SAAS,OAAT,GAAgB;AAC9D,MAAA,IAAI,CAAC,IAAL;;AACA,MAAA,IAAI,CAAC,gBAAL,CAAsB,mBAAtB,CAA0C,OAA1C,EAAmD,OAAnD;AACD,KAHD;;AAKA,QAAI,KAAK,QAAT,EAAmB;AACjB,WAAK,QAAL,CAAc,KAAd,GAAsB,IAAtB;AACA,WAAK,QAAL,CAAc,SAAd,GAA0B,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,EAAuB,KAAK,QAA5B,CAA1B,CAFiB,CAIjB;;AACA,WAAK,OAAL,CAAa,KAAK,QAAlB,EAA4B,KAAK,gBAAjC;;AAEA,WAAK,YAAL,CAAkB,MAAlB,CAAyB,KAAK,QAA9B;AACD;AACF,GApBD;AAsBA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACE,SAAK,IAAL,CAAU,KAAV,CAAgB,OAAhB;;AACA,QAAI,KAAK,QAAT,EAAmB;AACjB,WAAK,QAAL,CAAc,MAAd;;AACA,WAAK,QAAL,CAAc,SAAd,GAA0B,IAA1B;AACA,WAAK,QAAL,CAAc,SAAd,GAA0B,IAA1B;AACA,WAAK,QAAL,GAAgB,IAAhB;AACD;AACF,GARD;;AAUA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,EAAP,EAAS;AAAT,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,OAAO,EAAP,KAAc,QAAlB,EAA4B;AAC1B,MAAA,EAAE,GAAG,KAAK,cAAL,CAAoB,EAApB,CAAL;AACD,KAFD,MAEO,IAAI,CAAC,EAAL,EAAS;AACd,MAAA,EAAE,GAAG,KAAK,cAAL,EAAL;AACD;;AACD,SAAK,IAAL,CAAU,KAAV,CAAgB,kCAAhB,EAAoD,EAApD;;AACA,IAAA,EAAE,GAAG,KAAK,OAAL,CAAa,EAAb,CAAL;;AAEA,QAAI,KAAK,2BAAL,IAAoC,CAAC,KAAK,QAAL,CAAc,GAAd,CAAkB,EAAlB,CAAzC,EAAgE;AAC9D,UAAM,uBAAuB,GAAG,KAAK,oCAAL,GAC5B,YAAA;AAAM,eAAA,8BAA8B,CAAC,EAAD,EAAK,KAAI,CAAvC,IAA8B,CAA9B;AAA6C,OADvB,GAE5B,IAFJ;;AAGA,WAAK,QAAL,CAAc,GAAd,CAAkB,EAAlB,EAAsB,gBAAgB,CAAC,EAAD,EAAK,uBAAL,CAAtC;AACD;;AACD,WAAO,EAAP;AACD,GAhBD;AAkBA;;;;;;;AAOG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,EAAR,EAAY,gBAAZ,EAA2E;AAA/D,QAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,gBAAA,GAAmB,KAAK,cAAL,IAAuB,KAAK,gBAA/C;AAA+D;;AACzE,QAAI,WAAW,GAAG,EAAE,CAAC,SAArB;;AACA,QAAI,EAAE,WAAW,YAAY,KAAK,YAA9B,CAAJ,EAAiD;AAC/C,MAAA,WAAW,GAAG,IAAI,KAAK,YAAT,EAAd;AACD;;AAED,QAAM,SAAS,GAAG,gBAAgB,CAAC,IAAjB,KAA0B,OAA1B,GACd,gBADc,GAEd,gBAFJ;AAIA,IAAA,WAAW,CAAC,SAAD,CAAX,GAAyB,OAAzB,CAAiC,UAAA,KAAA,EAAK;AACpC,MAAA,WAAW,CAAC,WAAZ,CAAwB,KAAxB;AACD,KAFD;AAGA,IAAA,WAAW,CAAC,QAAZ,CAAqB,gBAArB,EAbyE,CAezE;AACA;AACA;;AACA,IAAA,EAAE,CAAC,SAAH,GAAe,WAAf;AACA,IAAA,EAAE,CAAC,QAAH,GAAc,IAAd;AACA,IAAA,EAAE,CAAC,WAAH,GAAiB,IAAjB;;AAEA,QAAI,CAAC,KAAK,YAAL,CAAkB,GAAlB,CAAsB,EAAtB,CAAL,EAAgC;AAC9B,WAAK,YAAL,CAAkB,GAAlB,CAAsB,EAAtB;AACD;;AAED,WAAO,EAAP;AACD,GA3BD;AA6BA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,QAAf,EAAuB;AACrB,QAAM,EAAE,GAAG,QAAQ,CAAC,aAAT,CAAuB,QAAvB,CAAX;;AAEA,QAAI,CAAC,EAAL,EAAS;AACP,YAAM,IAAI,KAAJ,CAAU,kCAAgC,QAA1C,CAAN;AACD;;AAED,WAAO,EAAP;AACD,GARD;AAUA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,+BAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,SAAK,IAAL,CAAU,KAAV,CAAgB,qDAAhB;;AACA,SAAK,uBAAL,GAA+B,OAA/B,CAAuC,UAAA,EAAA,EAAE;AAAI,aAAA,KAAI,CAAC,OAAL,CAAA,EAAA,CAAA;AAAgB,KAA7D;AACD,GAHD;AAKA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,WAAO,OAAO,QAAP,KAAoB,WAApB,GACH,QAAQ,CAAC,aAAT,CAAuB,KAAK,IAA5B,CADG,GAEH,IAFJ;AAGD,GAJD;;AAMA,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,EAAP,EAAS;AACP,QAAI,GAAJ;;AAEA,QAAI,OAAO,EAAP,KAAc,QAAlB,EAA4B;AAC1B,MAAA,GAAG,GAAG,CAAC,KAAK,cAAL,CAAoB,EAApB,CAAD,CAAN;AACD,KAFD,MAEO,IAAI,CAAC,EAAL,EAAS;AACd,MAAA,GAAG,GAAG,KAAK,uBAAL,EAAN;AACD,KAFM,MAEA;AACL,MAAA,GAAG,GAAG,CAAC,EAAD,CAAN;AACD;;AAED,SAAK,IAAL,CAAU,KAAV,CAAgB,qCAAhB,EAAuD,GAAvD;;AACA,SAAK,eAAL,CAAqB,GAArB;;AACA,WAAO,EAAE,GAAG,GAAG,CAAC,CAAD,CAAN,GAAY,GAArB;AACD,GAdD;AAgBA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,QAAhB,EAAwB;AACtB,WAAO,QAAQ,CAAC,GAAT,CAAa,KAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB,CAAb,CAAP;AACD,GAFD;AAIA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,EAAf,EAAiB;AACf,QAAI,CAAC,KAAK,YAAL,CAAkB,GAAlB,CAAsB,EAAtB,CAAL,EAAgC;AAC9B,aAAO,EAAP;AACD;;AACD,QAAM,WAAW,GAAG,EAAE,CAAC,SAAvB;;AACA,QAAI,WAAW,YAAY,KAAK,YAAhC,EAA8C;AAC5C,MAAA,WAAW,CAAC,WAAZ,CAAwB,KAAK,cAAL,IAAuB,KAAK,gBAApD;AACD;;AACD,SAAK,YAAL,CAAkB,MAAlB,CAAyB,EAAzB;;AAEA,QAAI,KAAK,2BAAL,IAAoC,KAAK,QAAL,CAAc,GAAd,CAAkB,EAAlB,CAAxC,EAA+D;AAC7D,UAAM,IAAI,GAAG,KAAK,QAAL,CAAc,GAAd,CAAkB,EAAlB,CAAb;;AACA,MAAA,IAAI,CAAC,MAAL;;AACA,WAAK,QAAL,CAAc,MAAd,CAAqB,EAArB;AACD;;AAED,WAAO,EAAP;AACD,GAjBD;AAmBA;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,YAAA;AACE,QAAM,GAAG,GAAG,EAAZ;;AAEA,SAAK,YAAL,CAAkB,OAAlB,CAA0B,UAAA,EAAA,EAAE;AAC1B,MAAA,GAAG,CAAC,IAAJ,CAAS,EAAT;AACD,KAFD;;AAIA,WAAO,GAAP;AACD,GARD;;AASF,SAAA,UAAA;AAAC,CA9QD,CAAyB,KAAzB,CAAA;AAgRA;;;;;;AAMG;;;AACH,SAAS,8BAAT,CAAwC,EAAxC,EAA4C,GAA5C,EAA+C;AAC7C,MAAM,GAAG,GAAG,EAAE,CAAC,OAAH,CAAW,WAAX,EAAZ;AACA,EAAA,GAAG,CAAC,IAAJ,CAAS,yBAAT,EAAoC,EAApC,EAF6C,CAI7C;AACA;AACA;;AACA,EAAA,OAAO,CAAC,IAAR,CAAa,CACX,YAAY,CAAC,QAAD,EAAW,kBAAX,CADD,EAEX,eAAe,CAAC,IAAD,CAFJ,CAAb,EAGG,IAHH,CAGQ,YAAA;AACN,QAAI,QAAQ,CAAC,eAAT,KAA6B,SAAjC,EAA4C;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAA,0BAA0B,CAAC,YAA3B,CAAwC,OAAxC,EAAiD,IAAjD,CAAsD,YAAA;AACpD,QAAA,GAAG,CAAC,IAAJ,CAAS,qCAAmC,GAAnC,GAAsC,WAA/C;AACA,QAAA,GAAG,CAAC,KAAJ,CAAU,UAAV,EAAsB,EAAtB;AACA,eAAO,EAAE,CAAC,IAAH,EAAP;AACD,OAJD,EAIG,IAJH,CAIQ,YAAA;AACN,QAAA,GAAG,CAAC,IAAJ,CAAS,iDAA+C,GAA/C,GAAkD,WAA3D;AACA,QAAA,GAAG,CAAC,KAAJ,CAAU,UAAV,EAAsB,EAAtB;AACD,OAPD,EAOG,KAPH,CAOS,UAAA,KAAA,EAAK;AACZ,QAAA,GAAG,CAAC,IAAJ,CAAS,iDAA+C,GAA/C,GAAkD,YAA3D,EAAyE;AAAE,UAAA,KAAK,EAAA,KAAP;AAAS,UAAA,EAAE,EAAA;AAAX,SAAzE;AACD,OATD;AAUD;AACF,GArBD;AAsBD;AAED;;;;;;AAMG;;;AACH,SAAS,gBAAT,CAA0B,EAA1B,EAA8B,uBAA9B,EAA4D;AAA9B,MAAA,uBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,uBAAA,GAAA,IAAA;AAA8B;;AAC1D,MAAM,SAAS,GAAG,EAAE,CAAC,KAArB;AACA,MAAM,QAAQ,GAAG,EAAE,CAAC,IAApB;AAEA,MAAI,oBAAmB,GAAG,KAA1B;;AAEA,EAAA,EAAE,CAAC,KAAH,GAAW,YAAA;AACT,IAAA,oBAAmB,GAAG,IAAtB;AACA,WAAO,SAAS,CAAC,IAAV,CAAe,EAAf,CAAP;AACD,GAHD;;AAKA,EAAA,EAAE,CAAC,IAAH,GAAU,YAAA;AACR,IAAA,oBAAmB,GAAG,KAAtB;AACA,WAAO,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAP;AACD,GAHD;;AAKA,MAAM,OAAO,GAAG,uBAAuB,GAAG,YAAA;AACxC,QAAI,CAAC,oBAAL,EAA0B;AACxB,MAAA,uBAAuB;AACxB;AACF,GAJsC,GAInC,IAJJ;;AAMA,MAAI,OAAJ,EAAa;AACX,IAAA,EAAE,CAAC,gBAAH,CAAoB,OAApB,EAA6B,OAA7B;AACD;;AAED,SAAO;AACL,IAAA,mBAAmB,EAAA,+BAAA;AACjB,aAAO,oBAAP;AACD,KAHI;AAIL,IAAA,MAAM,EAAA,kBAAA;AACJ,MAAA,EAAE,CAAC,KAAH,GAAW,SAAX;AACA,MAAA,EAAE,CAAC,IAAH,GAAU,QAAV;;AACA,UAAI,OAAJ,EAAa;AACX,QAAA,EAAE,CAAC,mBAAH,CAAuB,OAAvB,EAAgC,OAAhC;AACD;AACF;AAVI,GAAP;AAYD;;AAED,MAAM,CAAC,OAAP,GAAiB,UAAjB","sourceRoot":"","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a = require('@twilio/webrtc/lib/util'), guessBrowser = _a.guessBrowser, isIOSChrome = _a.isIOSChrome;\nvar MediaStream = require('@twilio/webrtc').MediaStream;\nvar _b = require('../../util'), waitForEvent = _b.waitForEvent, waitForSometime = _b.waitForSometime;\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar Track = require('./');\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\nvar MediaTrack = /** @class */ (function (_super) {\n    __extends(MediaTrack, _super);\n    /**\n     * Construct a {@link MediaTrack}.\n     * @param {MediaTrackTransceiver} mediaTrackTransceiver\n     * @param {{log: Log}} options\n     */\n    function MediaTrack(mediaTrackTransceiver, options) {\n        var _this = this;\n        options = Object.assign({\n            playPausedElementsIfNotBackgrounded: (guessBrowser() === 'safari' || isIOSChrome())\n                && typeof document === 'object'\n                && typeof document.addEventListener === 'function'\n                && typeof document.visibilityState === 'string'\n        }, options);\n        _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;\n        var isStarted = false;\n        options = Object.assign({\n            MediaStream: MediaStream\n        }, options);\n        /* istanbul ignore next */\n        Object.defineProperties(_this, {\n            _attachments: {\n                value: new Set()\n            },\n            _dummyEl: {\n                value: null,\n                writable: true\n            },\n            _elShims: {\n                value: new WeakMap()\n            },\n            _isStarted: {\n                get: function () {\n                    return isStarted;\n                },\n                set: function (_isStarted) {\n                    isStarted = _isStarted;\n                }\n            },\n            _playPausedElementsIfNotBackgrounded: {\n                value: options.playPausedElementsIfNotBackgrounded\n            },\n            _shouldShimAttachedElements: {\n                value: options.workaroundWebKitBug212780\n                    || options.playPausedElementsIfNotBackgrounded\n            },\n            _unprocessedTrack: {\n                value: null,\n                writable: true\n            },\n            _MediaStream: {\n                value: options.MediaStream\n            },\n            isStarted: {\n                enumerable: true,\n                get: function () {\n                    return isStarted;\n                }\n            },\n            mediaStreamTrack: {\n                enumerable: true,\n                get: function () {\n                    return this._unprocessedTrack || mediaTrackTransceiver.track;\n                }\n            },\n            processedTrack: {\n                enumerable: true,\n                value: null,\n                writable: true\n            }\n        });\n        _this._initialize();\n        return _this;\n    }\n    /**\n     * @private\n     */\n    MediaTrack.prototype._start = function () {\n        this._log.debug('Started');\n        this._isStarted = true;\n        if (this._dummyEl) {\n            this._dummyEl.oncanplay = null;\n        }\n        // eslint-disable-next-line no-use-before-define\n        this.emit('started', this);\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._initialize = function () {\n        var self = this;\n        this._log.debug('Initializing');\n        this._dummyEl = this._createElement();\n        this.mediaStreamTrack.addEventListener('ended', function onended() {\n            self._end();\n            self.mediaStreamTrack.removeEventListener('ended', onended);\n        });\n        if (this._dummyEl) {\n            this._dummyEl.muted = true;\n            this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);\n            // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n            this._attach(this._dummyEl, this.mediaStreamTrack);\n            this._attachments.delete(this._dummyEl);\n        }\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._end = function () {\n        this._log.debug('Ended');\n        if (this._dummyEl) {\n            this._dummyEl.remove();\n            this._dummyEl.srcObject = null;\n            this._dummyEl.oncanplay = null;\n            this._dummyEl = null;\n        }\n    };\n    MediaTrack.prototype.attach = function (el) {\n        var _this = this;\n        if (typeof el === 'string') {\n            el = this._selectElement(el);\n        }\n        else if (!el) {\n            el = this._createElement();\n        }\n        this._log.debug('Attempting to attach to element:', el);\n        el = this._attach(el);\n        if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n            var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded\n                ? function () { return playIfPausedAndNotBackgrounded(el, _this._log); }\n                : null;\n            this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n        }\n        return el;\n    };\n    /**\n     * Attach the provided MediaStreamTrack to the media element.\n     * @param el - The media element to attach to\n     * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n     * not provided, it uses the processedTrack if it exists\n     * or it defaults to the current mediaStreamTrack\n     * @private\n     */\n    MediaTrack.prototype._attach = function (el, mediaStreamTrack) {\n        if (mediaStreamTrack === void 0) { mediaStreamTrack = this.processedTrack || this.mediaStreamTrack; }\n        var mediaStream = el.srcObject;\n        if (!(mediaStream instanceof this._MediaStream)) {\n            mediaStream = new this._MediaStream();\n        }\n        var getTracks = mediaStreamTrack.kind === 'audio'\n            ? 'getAudioTracks'\n            : 'getVideoTracks';\n        mediaStream[getTracks]().forEach(function (track) {\n            mediaStream.removeTrack(track);\n        });\n        mediaStream.addTrack(mediaStreamTrack);\n        // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n        // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n        //\n        el.srcObject = mediaStream;\n        el.autoplay = true;\n        el.playsInline = true;\n        if (!this._attachments.has(el)) {\n            this._attachments.add(el);\n        }\n        return el;\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._selectElement = function (selector) {\n        var el = document.querySelector(selector);\n        if (!el) {\n            throw new Error(\"Selector matched no element: \" + selector);\n        }\n        return el;\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._updateElementsMediaStreamTrack = function () {\n        var _this = this;\n        this._log.debug('Reattaching all elements to update mediaStreamTrack');\n        this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._createElement = function () {\n        return typeof document !== 'undefined'\n            ? document.createElement(this.kind)\n            : null;\n    };\n    MediaTrack.prototype.detach = function (el) {\n        var els;\n        if (typeof el === 'string') {\n            els = [this._selectElement(el)];\n        }\n        else if (!el) {\n            els = this._getAllAttachedElements();\n        }\n        else {\n            els = [el];\n        }\n        this._log.debug('Attempting to detach from elements:', els);\n        this._detachElements(els);\n        return el ? els[0] : els;\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._detachElements = function (elements) {\n        return elements.map(this._detachElement.bind(this));\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._detachElement = function (el) {\n        if (!this._attachments.has(el)) {\n            return el;\n        }\n        var mediaStream = el.srcObject;\n        if (mediaStream instanceof this._MediaStream) {\n            mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n        }\n        this._attachments.delete(el);\n        if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n            var shim = this._elShims.get(el);\n            shim.unShim();\n            this._elShims.delete(el);\n        }\n        return el;\n    };\n    /**\n     * @private\n     */\n    MediaTrack.prototype._getAllAttachedElements = function () {\n        var els = [];\n        this._attachments.forEach(function (el) {\n            els.push(el);\n        });\n        return els;\n    };\n    return MediaTrack;\n}(Track));\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\nfunction playIfPausedAndNotBackgrounded(el, log) {\n    var tag = el.tagName.toLowerCase();\n    log.warn('Unintentionally paused:', el);\n    // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n    // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n    // app will be backgrounded. If not, then the element can be safely played.\n    Promise.race([\n        waitForEvent(document, 'visibilitychange'),\n        waitForSometime(1000)\n    ]).then(function () {\n        if (document.visibilityState === 'visible') {\n            // NOTE(mmalavalli): We play the inadvertently paused elements only after\n            // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n            //\n            // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n            //\n            localMediaRestartDeferreds.whenResolved('audio').then(function () {\n                log.info(\"Playing unintentionally paused <\" + tag + \"> element\");\n                log.debug('Element:', el);\n                return el.play();\n            }).then(function () {\n                log.info(\"Successfully played unintentionally paused <\" + tag + \"> element\");\n                log.debug('Element:', el);\n            }).catch(function (error) {\n                log.warn(\"Error while playing unintentionally paused <\" + tag + \"> element:\", { error: error, el: el });\n            });\n        }\n    });\n}\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\nfunction shimMediaElement(el, onUnintentionallyPaused) {\n    if (onUnintentionallyPaused === void 0) { onUnintentionallyPaused = null; }\n    var origPause = el.pause;\n    var origPlay = el.play;\n    var pausedIntentionally = false;\n    el.pause = function () {\n        pausedIntentionally = true;\n        return origPause.call(el);\n    };\n    el.play = function () {\n        pausedIntentionally = false;\n        return origPlay.call(el);\n    };\n    var onPause = onUnintentionallyPaused ? function () {\n        if (!pausedIntentionally) {\n            onUnintentionallyPaused();\n        }\n    } : null;\n    if (onPause) {\n        el.addEventListener('pause', onPause);\n    }\n    return {\n        pausedIntentionally: function () {\n            return pausedIntentionally;\n        },\n        unShim: function () {\n            el.pause = origPause;\n            el.play = origPlay;\n            if (onPause) {\n                el.removeEventListener('pause', onPause);\n            }\n        }\n    };\n}\nmodule.exports = MediaTrack;\n//# sourceMappingURL=mediatrack.js.map"]},"metadata":{},"sourceType":"script"}